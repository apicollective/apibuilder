/**
  * Generated by API Builder - https://www.apibuilder.io
  * Service version: 0.16.48
  * User agent: apibuilder app.apibuilder.io/apicollective/apibuilder-api/latest/play_2_6_controllers
  */
package io.apibuilder.api.v0.controllers

import io.apibuilder.api.v0.models.json._
import io.apibuilder.common.v0.models.json._
import io.apibuilder.generator.v0.models.json._
import io.apibuilder.spec.v0.models.json._

trait ApplicationsController extends play.api.mvc.BaseController {

  sealed trait GetMetadataAndVersionsByApplicationKey extends Product with Serializable
  object GetMetadataAndVersionsByApplicationKey {
    final case class HTTP200(body: Seq[io.apibuilder.api.v0.models.ApplicationMetadataVersion])
        extends GetMetadataAndVersionsByApplicationKey
    case object HTTP401 extends GetMetadataAndVersionsByApplicationKey
    case object HTTP404 extends GetMetadataAndVersionsByApplicationKey
    final case class Undocumented(result: play.api.mvc.Result) extends GetMetadataAndVersionsByApplicationKey
  }

  def getMetadataAndVersionsByApplicationKey(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      orgKey: String,
      applicationKey: String,
      limit: Long,
      offset: Long
  ): scala.concurrent.Future[GetMetadataAndVersionsByApplicationKey]
  final def getMetadataAndVersionsByApplicationKey(
      orgKey: String,
      applicationKey: String,
      limit: Long,
      offset: Long
  ): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async { request =>
    getMetadataAndVersionsByApplicationKey(request, orgKey, applicationKey, limit, offset)
      .map {
        case r: GetMetadataAndVersionsByApplicationKey.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
        case GetMetadataAndVersionsByApplicationKey.HTTP401         => Status(401)(play.api.mvc.Results.EmptyContent())
        case GetMetadataAndVersionsByApplicationKey.HTTP404         => Status(404)(play.api.mvc.Results.EmptyContent())
        case r: GetMetadataAndVersionsByApplicationKey.Undocumented => r.result
      }(defaultExecutionContext)
  }

  sealed trait GetMetadataAndVersionsAndLatestTxtByApplicationKey extends Product with Serializable
  object GetMetadataAndVersionsAndLatestTxtByApplicationKey {
    final case class HTTP200(body: String) extends GetMetadataAndVersionsAndLatestTxtByApplicationKey
    case object HTTP401 extends GetMetadataAndVersionsAndLatestTxtByApplicationKey
    case object HTTP404 extends GetMetadataAndVersionsAndLatestTxtByApplicationKey
    final case class Undocumented(result: play.api.mvc.Result)
        extends GetMetadataAndVersionsAndLatestTxtByApplicationKey
  }

  def getMetadataAndVersionsAndLatestTxtByApplicationKey(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      orgKey: String,
      applicationKey: String
  ): scala.concurrent.Future[GetMetadataAndVersionsAndLatestTxtByApplicationKey]
  final def getMetadataAndVersionsAndLatestTxtByApplicationKey(
      orgKey: String,
      applicationKey: String
  ): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async { request =>
    getMetadataAndVersionsAndLatestTxtByApplicationKey(request, orgKey, applicationKey)
      .map {
        case r: GetMetadataAndVersionsAndLatestTxtByApplicationKey.HTTP200 =>
          Status(200)(play.api.libs.json.Json.toJson(r.body))
        case GetMetadataAndVersionsAndLatestTxtByApplicationKey.HTTP401 =>
          Status(401)(play.api.mvc.Results.EmptyContent())
        case GetMetadataAndVersionsAndLatestTxtByApplicationKey.HTTP404 =>
          Status(404)(play.api.mvc.Results.EmptyContent())
        case r: GetMetadataAndVersionsAndLatestTxtByApplicationKey.Undocumented => r.result
      }(defaultExecutionContext)
  }

  sealed trait Get extends Product with Serializable
  object Get {
    final case class HTTP200(body: Seq[io.apibuilder.api.v0.models.Application]) extends Get
    final case class Undocumented(result: play.api.mvc.Result) extends Get
  }

  def get(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      orgKey: String,
      name: _root_.scala.Option[String],
      guid: _root_.scala.Option[_root_.java.util.UUID],
      key: _root_.scala.Option[String],
      hasVersion: _root_.scala.Option[Boolean],
      limit: Long,
      offset: Long,
      sortBy: _root_.scala.Option[io.apibuilder.api.v0.models.AppSortBy],
      order: _root_.scala.Option[io.apibuilder.api.v0.models.SortOrder]
  ): scala.concurrent.Future[Get]
  final def get(
      orgKey: String,
      name: _root_.scala.Option[String],
      guid: _root_.scala.Option[_root_.java.util.UUID],
      key: _root_.scala.Option[String],
      hasVersion: _root_.scala.Option[Boolean],
      limit: Long,
      offset: Long,
      sortBy: _root_.scala.Option[io.apibuilder.api.v0.models.AppSortBy],
      order: _root_.scala.Option[io.apibuilder.api.v0.models.SortOrder]
  ): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async { request =>
    get(request, orgKey, name, guid, key, hasVersion, limit, offset, sortBy, order)
      .map {
        case r: Get.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
        case r: Get.Undocumented => r.result
      }(defaultExecutionContext)
  }

  sealed trait Post extends Product with Serializable
  object Post {
    final case class HTTP200(body: io.apibuilder.api.v0.models.Application) extends Post
    final case class HTTP409(body: Seq[io.apibuilder.api.v0.models.Error]) extends Post
    final case class Undocumented(result: play.api.mvc.Result) extends Post
  }

  def post(
      request: play.api.mvc.Request[io.apibuilder.api.v0.models.ApplicationForm],
      orgKey: String,
      body: io.apibuilder.api.v0.models.ApplicationForm
  ): scala.concurrent.Future[Post]
  final def post(orgKey: String): play.api.mvc.Action[io.apibuilder.api.v0.models.ApplicationForm] =
    Action.async(parse.json[io.apibuilder.api.v0.models.ApplicationForm]) { request =>
      post(request, orgKey, request.body)
        .map {
          case r: Post.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
          case r: Post.HTTP409      => Status(409)(play.api.libs.json.Json.toJson(r.body))
          case r: Post.Undocumented => r.result
        }(defaultExecutionContext)
    }

  sealed trait PutByApplicationKey extends Product with Serializable
  object PutByApplicationKey {
    final case class HTTP200(body: io.apibuilder.api.v0.models.Application) extends PutByApplicationKey
    final case class HTTP409(body: Seq[io.apibuilder.api.v0.models.Error]) extends PutByApplicationKey
    final case class Undocumented(result: play.api.mvc.Result) extends PutByApplicationKey
  }

  def putByApplicationKey(
      request: play.api.mvc.Request[io.apibuilder.api.v0.models.ApplicationForm],
      orgKey: String,
      applicationKey: String,
      body: io.apibuilder.api.v0.models.ApplicationForm
  ): scala.concurrent.Future[PutByApplicationKey]
  final def putByApplicationKey(
      orgKey: String,
      applicationKey: String
  ): play.api.mvc.Action[io.apibuilder.api.v0.models.ApplicationForm] =
    Action.async(parse.json[io.apibuilder.api.v0.models.ApplicationForm]) { request =>
      putByApplicationKey(request, orgKey, applicationKey, request.body)
        .map {
          case r: PutByApplicationKey.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
          case r: PutByApplicationKey.HTTP409      => Status(409)(play.api.libs.json.Json.toJson(r.body))
          case r: PutByApplicationKey.Undocumented => r.result
        }(defaultExecutionContext)
    }

  sealed trait DeleteByApplicationKey extends Product with Serializable
  object DeleteByApplicationKey {
    case object HTTP204 extends DeleteByApplicationKey
    case object HTTP401 extends DeleteByApplicationKey
    case object HTTP404 extends DeleteByApplicationKey
    final case class Undocumented(result: play.api.mvc.Result) extends DeleteByApplicationKey
  }

  def deleteByApplicationKey(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      orgKey: String,
      applicationKey: String
  ): scala.concurrent.Future[DeleteByApplicationKey]
  final def deleteByApplicationKey(
      orgKey: String,
      applicationKey: String
  ): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async { request =>
    deleteByApplicationKey(request, orgKey, applicationKey)
      .map {
        case DeleteByApplicationKey.HTTP204         => Status(204)(play.api.mvc.Results.EmptyContent())
        case DeleteByApplicationKey.HTTP401         => Status(401)(play.api.mvc.Results.EmptyContent())
        case DeleteByApplicationKey.HTTP404         => Status(404)(play.api.mvc.Results.EmptyContent())
        case r: DeleteByApplicationKey.Undocumented => r.result
      }(defaultExecutionContext)
  }

  sealed trait PostMoveByApplicationKey extends Product with Serializable
  object PostMoveByApplicationKey {
    final case class HTTP200(body: io.apibuilder.api.v0.models.Application) extends PostMoveByApplicationKey
    final case class HTTP409(body: Seq[io.apibuilder.api.v0.models.Error]) extends PostMoveByApplicationKey
    final case class Undocumented(result: play.api.mvc.Result) extends PostMoveByApplicationKey
  }

  def postMoveByApplicationKey(
      request: play.api.mvc.Request[io.apibuilder.api.v0.models.MoveForm],
      orgKey: String,
      applicationKey: String,
      body: io.apibuilder.api.v0.models.MoveForm
  ): scala.concurrent.Future[PostMoveByApplicationKey]
  final def postMoveByApplicationKey(
      orgKey: String,
      applicationKey: String
  ): play.api.mvc.Action[io.apibuilder.api.v0.models.MoveForm] =
    Action.async(parse.json[io.apibuilder.api.v0.models.MoveForm]) { request =>
      postMoveByApplicationKey(request, orgKey, applicationKey, request.body)
        .map {
          case r: PostMoveByApplicationKey.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
          case r: PostMoveByApplicationKey.HTTP409      => Status(409)(play.api.libs.json.Json.toJson(r.body))
          case r: PostMoveByApplicationKey.Undocumented => r.result
        }(defaultExecutionContext)
    }

}

trait AttributesController extends play.api.mvc.BaseController {

  sealed trait Get extends Product with Serializable
  object Get {
    final case class HTTP200(body: Seq[io.apibuilder.api.v0.models.Attribute]) extends Get
    final case class Undocumented(result: play.api.mvc.Result) extends Get
  }

  def get(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      guid: _root_.scala.Option[_root_.java.util.UUID],
      name: _root_.scala.Option[String],
      limit: Long,
      offset: Long
  ): scala.concurrent.Future[Get]
  final def get(
      guid: _root_.scala.Option[_root_.java.util.UUID],
      name: _root_.scala.Option[String],
      limit: Long,
      offset: Long
  ): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async { request =>
    get(request, guid, name, limit, offset)
      .map {
        case r: Get.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
        case r: Get.Undocumented => r.result
      }(defaultExecutionContext)
  }

  sealed trait GetByName extends Product with Serializable
  object GetByName {
    final case class HTTP200(body: io.apibuilder.api.v0.models.Attribute) extends GetByName
    case object HTTP404 extends GetByName
    final case class Undocumented(result: play.api.mvc.Result) extends GetByName
  }

  def getByName(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      name: String
  ): scala.concurrent.Future[GetByName]
  final def getByName(name: String): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async { request =>
    getByName(request, name)
      .map {
        case r: GetByName.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
        case GetByName.HTTP404         => Status(404)(play.api.mvc.Results.EmptyContent())
        case r: GetByName.Undocumented => r.result
      }(defaultExecutionContext)
  }

  sealed trait Post extends Product with Serializable
  object Post {
    final case class HTTP201(body: io.apibuilder.api.v0.models.Attribute) extends Post
    case object HTTP401 extends Post
    final case class HTTP409(body: Seq[io.apibuilder.api.v0.models.Error]) extends Post
    final case class Undocumented(result: play.api.mvc.Result) extends Post
  }

  def post(
      request: play.api.mvc.Request[io.apibuilder.api.v0.models.AttributeForm],
      body: io.apibuilder.api.v0.models.AttributeForm
  ): scala.concurrent.Future[Post]
  final def post(): play.api.mvc.Action[io.apibuilder.api.v0.models.AttributeForm] =
    Action.async(parse.json[io.apibuilder.api.v0.models.AttributeForm]) { request =>
      post(request, request.body)
        .map {
          case r: Post.HTTP201      => Status(201)(play.api.libs.json.Json.toJson(r.body))
          case Post.HTTP401         => Status(401)(play.api.mvc.Results.EmptyContent())
          case r: Post.HTTP409      => Status(409)(play.api.libs.json.Json.toJson(r.body))
          case r: Post.Undocumented => r.result
        }(defaultExecutionContext)
    }

  sealed trait DeleteByName extends Product with Serializable
  object DeleteByName {
    case object HTTP204 extends DeleteByName
    case object HTTP401 extends DeleteByName
    case object HTTP404 extends DeleteByName
    final case class Undocumented(result: play.api.mvc.Result) extends DeleteByName
  }

  def deleteByName(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      name: String
  ): scala.concurrent.Future[DeleteByName]
  final def deleteByName(name: String): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async { request =>
    deleteByName(request, name)
      .map {
        case DeleteByName.HTTP204         => Status(204)(play.api.mvc.Results.EmptyContent())
        case DeleteByName.HTTP401         => Status(401)(play.api.mvc.Results.EmptyContent())
        case DeleteByName.HTTP404         => Status(404)(play.api.mvc.Results.EmptyContent())
        case r: DeleteByName.Undocumented => r.result
      }(defaultExecutionContext)
  }

}

trait AuthenticationsController extends play.api.mvc.BaseController {

  sealed trait GetSessionById extends Product with Serializable
  object GetSessionById {
    final case class HTTP200(body: io.apibuilder.api.v0.models.Authentication) extends GetSessionById
    case object HTTP404 extends GetSessionById
    final case class Undocumented(result: play.api.mvc.Result) extends GetSessionById
  }

  def getSessionById(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      id: String
  ): scala.concurrent.Future[GetSessionById]
  final def getSessionById(id: String): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async { request =>
    getSessionById(request, id)
      .map {
        case r: GetSessionById.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
        case GetSessionById.HTTP404         => Status(404)(play.api.mvc.Results.EmptyContent())
        case r: GetSessionById.Undocumented => r.result
      }(defaultExecutionContext)
  }

}

trait BatchesController extends play.api.mvc.BaseController {

  sealed trait Post extends Product with Serializable
  object Post {
    final case class HTTP201(body: io.apibuilder.api.v0.models.Batch) extends Post
    final case class HTTP409(body: Seq[io.apibuilder.api.v0.models.Error]) extends Post
    final case class Undocumented(result: play.api.mvc.Result) extends Post
  }

  def post(
      request: play.api.mvc.Request[io.apibuilder.api.v0.models.BatchForm],
      orgKey: String,
      body: io.apibuilder.api.v0.models.BatchForm
  ): scala.concurrent.Future[Post]
  final def post(orgKey: String): play.api.mvc.Action[io.apibuilder.api.v0.models.BatchForm] =
    Action.async(parse.json[io.apibuilder.api.v0.models.BatchForm]) { request =>
      post(request, orgKey, request.body)
        .map {
          case r: Post.HTTP201      => Status(201)(play.api.libs.json.Json.toJson(r.body))
          case r: Post.HTTP409      => Status(409)(play.api.libs.json.Json.toJson(r.body))
          case r: Post.Undocumented => r.result
        }(defaultExecutionContext)
    }

  sealed trait PostDryrun extends Product with Serializable
  object PostDryrun {
    final case class HTTP201(body: io.apibuilder.api.v0.models.Batch) extends PostDryrun
    final case class HTTP409(body: Seq[io.apibuilder.api.v0.models.Error]) extends PostDryrun
    final case class Undocumented(result: play.api.mvc.Result) extends PostDryrun
  }

  def postDryrun(
      request: play.api.mvc.Request[io.apibuilder.api.v0.models.BatchDownloadForm],
      orgKey: String,
      body: io.apibuilder.api.v0.models.BatchDownloadForm
  ): scala.concurrent.Future[PostDryrun]
  final def postDryrun(orgKey: String): play.api.mvc.Action[io.apibuilder.api.v0.models.BatchDownloadForm] =
    Action.async(parse.json[io.apibuilder.api.v0.models.BatchDownloadForm]) { request =>
      postDryrun(request, orgKey, request.body)
        .map {
          case r: PostDryrun.HTTP201      => Status(201)(play.api.libs.json.Json.toJson(r.body))
          case r: PostDryrun.HTTP409      => Status(409)(play.api.libs.json.Json.toJson(r.body))
          case r: PostDryrun.Undocumented => r.result
        }(defaultExecutionContext)
    }

  sealed trait PostDownload extends Product with Serializable
  object PostDownload {
    final case class HTTP201(body: io.apibuilder.api.v0.models.Batch) extends PostDownload
    final case class HTTP409(body: Seq[io.apibuilder.api.v0.models.Error]) extends PostDownload
    final case class Undocumented(result: play.api.mvc.Result) extends PostDownload
  }

  def postDownload(
      request: play.api.mvc.Request[io.apibuilder.api.v0.models.BatchDownloadForm],
      orgKey: String,
      body: io.apibuilder.api.v0.models.BatchDownloadForm
  ): scala.concurrent.Future[PostDownload]
  final def postDownload(orgKey: String): play.api.mvc.Action[io.apibuilder.api.v0.models.BatchDownloadForm] =
    Action.async(parse.json[io.apibuilder.api.v0.models.BatchDownloadForm]) { request =>
      postDownload(request, orgKey, request.body)
        .map {
          case r: PostDownload.HTTP201      => Status(201)(play.api.libs.json.Json.toJson(r.body))
          case r: PostDownload.HTTP409      => Status(409)(play.api.libs.json.Json.toJson(r.body))
          case r: PostDownload.Undocumented => r.result
        }(defaultExecutionContext)
    }

}

trait ChangesController extends play.api.mvc.BaseController {

  sealed trait Get extends Product with Serializable
  object Get {
    final case class HTTP200(body: Seq[io.apibuilder.api.v0.models.Change]) extends Get
    final case class Undocumented(result: play.api.mvc.Result) extends Get
  }

  def get(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      orgKey: _root_.scala.Option[String],
      applicationKey: _root_.scala.Option[String],
      from: _root_.scala.Option[String],
      to: _root_.scala.Option[String],
      `type`: _root_.scala.Option[String],
      limit: Long,
      offset: Long
  ): scala.concurrent.Future[Get]
  final def get(
      orgKey: _root_.scala.Option[String],
      applicationKey: _root_.scala.Option[String],
      from: _root_.scala.Option[String],
      to: _root_.scala.Option[String],
      `type`: _root_.scala.Option[String],
      limit: Long,
      offset: Long
  ): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async { request =>
    get(request, orgKey, applicationKey, from, to, `type`, limit, offset)
      .map {
        case r: Get.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
        case r: Get.Undocumented => r.result
      }(defaultExecutionContext)
  }

}

trait CodeController extends play.api.mvc.BaseController {

  sealed trait PostForm extends Product with Serializable
  object PostForm {
    final case class HTTP200(body: io.apibuilder.generator.v0.models.InvocationForm) extends PostForm
    final case class HTTP409(body: Seq[io.apibuilder.api.v0.models.Error]) extends PostForm
    final case class Undocumented(result: play.api.mvc.Result) extends PostForm
  }

  def postForm(
      request: play.api.mvc.Request[io.apibuilder.api.v0.models.CodeForm],
      orgKey: String,
      applicationKey: String,
      version: String,
      body: io.apibuilder.api.v0.models.CodeForm
  ): scala.concurrent.Future[PostForm]
  final def postForm(
      orgKey: String,
      applicationKey: String,
      version: String
  ): play.api.mvc.Action[io.apibuilder.api.v0.models.CodeForm] =
    Action.async(parse.json[io.apibuilder.api.v0.models.CodeForm]) { request =>
      postForm(request, orgKey, applicationKey, version, request.body)
        .map {
          case r: PostForm.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
          case r: PostForm.HTTP409      => Status(409)(play.api.libs.json.Json.toJson(r.body))
          case r: PostForm.Undocumented => r.result
        }(defaultExecutionContext)
    }

  sealed trait GetByGeneratorKey extends Product with Serializable
  object GetByGeneratorKey {
    final case class HTTP200(body: io.apibuilder.api.v0.models.Code) extends GetByGeneratorKey
    final case class HTTP409(body: Seq[io.apibuilder.api.v0.models.Error]) extends GetByGeneratorKey
    final case class Undocumented(result: play.api.mvc.Result) extends GetByGeneratorKey
  }

  def getByGeneratorKey(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      orgKey: String,
      applicationKey: String,
      version: String,
      generatorKey: String
  ): scala.concurrent.Future[GetByGeneratorKey]
  final def getByGeneratorKey(
      orgKey: String,
      applicationKey: String,
      version: String,
      generatorKey: String
  ): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async { request =>
    getByGeneratorKey(request, orgKey, applicationKey, version, generatorKey)
      .map {
        case r: GetByGeneratorKey.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
        case r: GetByGeneratorKey.HTTP409      => Status(409)(play.api.libs.json.Json.toJson(r.body))
        case r: GetByGeneratorKey.Undocumented => r.result
      }(defaultExecutionContext)
  }

  sealed trait PostByGeneratorKey extends Product with Serializable
  object PostByGeneratorKey {
    final case class HTTP200(body: io.apibuilder.api.v0.models.Code) extends PostByGeneratorKey
    final case class HTTP409(body: Seq[io.apibuilder.api.v0.models.Error]) extends PostByGeneratorKey
    final case class Undocumented(result: play.api.mvc.Result) extends PostByGeneratorKey
  }

  def postByGeneratorKey(
      request: play.api.mvc.Request[io.apibuilder.api.v0.models.CodeForm],
      orgKey: String,
      applicationKey: String,
      version: String,
      generatorKey: String,
      body: io.apibuilder.api.v0.models.CodeForm
  ): scala.concurrent.Future[PostByGeneratorKey]
  final def postByGeneratorKey(
      orgKey: String,
      applicationKey: String,
      version: String,
      generatorKey: String
  ): play.api.mvc.Action[io.apibuilder.api.v0.models.CodeForm] =
    Action.async(parse.json[io.apibuilder.api.v0.models.CodeForm]) { request =>
      postByGeneratorKey(request, orgKey, applicationKey, version, generatorKey, request.body)
        .map {
          case r: PostByGeneratorKey.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
          case r: PostByGeneratorKey.HTTP409      => Status(409)(play.api.libs.json.Json.toJson(r.body))
          case r: PostByGeneratorKey.Undocumented => r.result
        }(defaultExecutionContext)
    }

}

trait DomainsController extends play.api.mvc.BaseController {

  sealed trait Post extends Product with Serializable
  object Post {
    final case class HTTP200(body: io.apibuilder.api.v0.models.Domain) extends Post
    final case class HTTP409(body: Seq[io.apibuilder.api.v0.models.Error]) extends Post
    final case class Undocumented(result: play.api.mvc.Result) extends Post
  }

  def post(
      request: play.api.mvc.Request[io.apibuilder.api.v0.models.Domain],
      orgKey: String,
      body: io.apibuilder.api.v0.models.Domain
  ): scala.concurrent.Future[Post]
  final def post(orgKey: String): play.api.mvc.Action[io.apibuilder.api.v0.models.Domain] =
    Action.async(parse.json[io.apibuilder.api.v0.models.Domain]) { request =>
      post(request, orgKey, request.body)
        .map {
          case r: Post.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
          case r: Post.HTTP409      => Status(409)(play.api.libs.json.Json.toJson(r.body))
          case r: Post.Undocumented => r.result
        }(defaultExecutionContext)
    }

  sealed trait DeleteByName extends Product with Serializable
  object DeleteByName {
    case object HTTP204 extends DeleteByName
    case object HTTP401 extends DeleteByName
    case object HTTP404 extends DeleteByName
    final case class Undocumented(result: play.api.mvc.Result) extends DeleteByName
  }

  def deleteByName(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      orgKey: String,
      name: String
  ): scala.concurrent.Future[DeleteByName]
  final def deleteByName(orgKey: String, name: String): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async {
    request =>
      deleteByName(request, orgKey, name)
        .map {
          case DeleteByName.HTTP204         => Status(204)(play.api.mvc.Results.EmptyContent())
          case DeleteByName.HTTP401         => Status(401)(play.api.mvc.Results.EmptyContent())
          case DeleteByName.HTTP404         => Status(404)(play.api.mvc.Results.EmptyContent())
          case r: DeleteByName.Undocumented => r.result
        }(defaultExecutionContext)
  }

}

trait EmailVerificationConfirmationFormsController extends play.api.mvc.BaseController {

  sealed trait Post extends Product with Serializable
  object Post {
    case object HTTP204 extends Post
    final case class HTTP409(body: Seq[io.apibuilder.api.v0.models.Error]) extends Post
    final case class Undocumented(result: play.api.mvc.Result) extends Post
  }

  def post(
      request: play.api.mvc.Request[io.apibuilder.api.v0.models.EmailVerificationConfirmationForm],
      body: io.apibuilder.api.v0.models.EmailVerificationConfirmationForm
  ): scala.concurrent.Future[Post]
  final def post(): play.api.mvc.Action[io.apibuilder.api.v0.models.EmailVerificationConfirmationForm] =
    Action.async(parse.json[io.apibuilder.api.v0.models.EmailVerificationConfirmationForm]) { request =>
      post(request, request.body)
        .map {
          case Post.HTTP204         => Status(204)(play.api.mvc.Results.EmptyContent())
          case r: Post.HTTP409      => Status(409)(play.api.libs.json.Json.toJson(r.body))
          case r: Post.Undocumented => r.result
        }(defaultExecutionContext)
    }

}

trait GeneratorServicesController extends play.api.mvc.BaseController {

  sealed trait Get extends Product with Serializable
  object Get {
    final case class HTTP200(body: Seq[io.apibuilder.api.v0.models.GeneratorService]) extends Get
    final case class Undocumented(result: play.api.mvc.Result) extends Get
  }

  def get(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      guid: _root_.scala.Option[_root_.java.util.UUID],
      uri: _root_.scala.Option[String],
      generatorKey: _root_.scala.Option[String],
      limit: Long,
      offset: Long
  ): scala.concurrent.Future[Get]
  final def get(
      guid: _root_.scala.Option[_root_.java.util.UUID],
      uri: _root_.scala.Option[String],
      generatorKey: _root_.scala.Option[String],
      limit: Long,
      offset: Long
  ): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async { request =>
    get(request, guid, uri, generatorKey, limit, offset)
      .map {
        case r: Get.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
        case r: Get.Undocumented => r.result
      }(defaultExecutionContext)
  }

  sealed trait GetByGuid extends Product with Serializable
  object GetByGuid {
    final case class HTTP200(body: io.apibuilder.api.v0.models.GeneratorService) extends GetByGuid
    case object HTTP404 extends GetByGuid
    final case class Undocumented(result: play.api.mvc.Result) extends GetByGuid
  }

  def getByGuid(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      guid: _root_.java.util.UUID
  ): scala.concurrent.Future[GetByGuid]
  final def getByGuid(guid: _root_.java.util.UUID): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async {
    request =>
      getByGuid(request, guid)
        .map {
          case r: GetByGuid.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
          case GetByGuid.HTTP404         => Status(404)(play.api.mvc.Results.EmptyContent())
          case r: GetByGuid.Undocumented => r.result
        }(defaultExecutionContext)
  }

  sealed trait Post extends Product with Serializable
  object Post {
    final case class HTTP200(body: io.apibuilder.api.v0.models.GeneratorService) extends Post
    final case class HTTP409(body: Seq[io.apibuilder.api.v0.models.Error]) extends Post
    final case class Undocumented(result: play.api.mvc.Result) extends Post
  }

  def post(
      request: play.api.mvc.Request[io.apibuilder.api.v0.models.GeneratorServiceForm],
      body: io.apibuilder.api.v0.models.GeneratorServiceForm
  ): scala.concurrent.Future[Post]
  final def post(): play.api.mvc.Action[io.apibuilder.api.v0.models.GeneratorServiceForm] =
    Action.async(parse.json[io.apibuilder.api.v0.models.GeneratorServiceForm]) { request =>
      post(request, request.body)
        .map {
          case r: Post.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
          case r: Post.HTTP409      => Status(409)(play.api.libs.json.Json.toJson(r.body))
          case r: Post.Undocumented => r.result
        }(defaultExecutionContext)
    }

  sealed trait DeleteByGuid extends Product with Serializable
  object DeleteByGuid {
    case object HTTP204 extends DeleteByGuid
    case object HTTP401 extends DeleteByGuid
    case object HTTP404 extends DeleteByGuid
    final case class Undocumented(result: play.api.mvc.Result) extends DeleteByGuid
  }

  def deleteByGuid(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      guid: _root_.java.util.UUID
  ): scala.concurrent.Future[DeleteByGuid]
  final def deleteByGuid(guid: _root_.java.util.UUID): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async {
    request =>
      deleteByGuid(request, guid)
        .map {
          case DeleteByGuid.HTTP204         => Status(204)(play.api.mvc.Results.EmptyContent())
          case DeleteByGuid.HTTP401         => Status(401)(play.api.mvc.Results.EmptyContent())
          case DeleteByGuid.HTTP404         => Status(404)(play.api.mvc.Results.EmptyContent())
          case r: DeleteByGuid.Undocumented => r.result
        }(defaultExecutionContext)
  }

}

trait GeneratorWithServicesController extends play.api.mvc.BaseController {

  sealed trait Get extends Product with Serializable
  object Get {
    final case class HTTP200(body: Seq[io.apibuilder.api.v0.models.GeneratorWithService]) extends Get
    final case class Undocumented(result: play.api.mvc.Result) extends Get
  }

  def get(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      guid: _root_.scala.Option[_root_.java.util.UUID],
      serviceGuid: _root_.scala.Option[_root_.java.util.UUID],
      serviceUri: _root_.scala.Option[String],
      attributeName: _root_.scala.Option[String],
      key: _root_.scala.Option[String],
      limit: Long,
      offset: Long
  ): scala.concurrent.Future[Get]
  final def get(
      guid: _root_.scala.Option[_root_.java.util.UUID],
      serviceGuid: _root_.scala.Option[_root_.java.util.UUID],
      serviceUri: _root_.scala.Option[String],
      attributeName: _root_.scala.Option[String],
      key: _root_.scala.Option[String],
      limit: Long,
      offset: Long
  ): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async { request =>
    get(request, guid, serviceGuid, serviceUri, attributeName, key, limit, offset)
      .map {
        case r: Get.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
        case r: Get.Undocumented => r.result
      }(defaultExecutionContext)
  }

  sealed trait GetByKey extends Product with Serializable
  object GetByKey {
    final case class HTTP200(body: io.apibuilder.api.v0.models.GeneratorWithService) extends GetByKey
    case object HTTP404 extends GetByKey
    final case class Undocumented(result: play.api.mvc.Result) extends GetByKey
  }

  def getByKey(request: play.api.mvc.Request[play.api.mvc.AnyContent], key: String): scala.concurrent.Future[GetByKey]
  final def getByKey(key: String): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async { request =>
    getByKey(request, key)
      .map {
        case r: GetByKey.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
        case GetByKey.HTTP404         => Status(404)(play.api.mvc.Results.EmptyContent())
        case r: GetByKey.Undocumented => r.result
      }(defaultExecutionContext)
  }

}

trait HealthchecksController extends play.api.mvc.BaseController {

  sealed trait GetHealthcheck extends Product with Serializable
  object GetHealthcheck {
    final case class HTTP200(body: io.apibuilder.generator.v0.models.Healthcheck) extends GetHealthcheck
    final case class Undocumented(result: play.api.mvc.Result) extends GetHealthcheck
  }

  def getHealthcheck(request: play.api.mvc.Request[play.api.mvc.AnyContent]): scala.concurrent.Future[GetHealthcheck]
  final def getHealthcheck(): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async { request =>
    getHealthcheck(request)
      .map {
        case r: GetHealthcheck.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
        case r: GetHealthcheck.Undocumented => r.result
      }(defaultExecutionContext)
  }

}

trait ItemsController extends play.api.mvc.BaseController {

  sealed trait Get extends Product with Serializable
  object Get {
    final case class HTTP200(body: Seq[io.apibuilder.api.v0.models.Item]) extends Get
    final case class Undocumented(result: play.api.mvc.Result) extends Get
  }

  def get(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      q: _root_.scala.Option[String],
      limit: Long,
      offset: Long
  ): scala.concurrent.Future[Get]
  final def get(
      q: _root_.scala.Option[String],
      limit: Long,
      offset: Long
  ): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async { request =>
    get(request, q, limit, offset)
      .map {
        case r: Get.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
        case r: Get.Undocumented => r.result
      }(defaultExecutionContext)
  }

  sealed trait GetByGuid extends Product with Serializable
  object GetByGuid {
    final case class HTTP200(body: io.apibuilder.api.v0.models.Item) extends GetByGuid
    case object HTTP404 extends GetByGuid
    final case class Undocumented(result: play.api.mvc.Result) extends GetByGuid
  }

  def getByGuid(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      guid: _root_.java.util.UUID
  ): scala.concurrent.Future[GetByGuid]
  final def getByGuid(guid: _root_.java.util.UUID): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async {
    request =>
      getByGuid(request, guid)
        .map {
          case r: GetByGuid.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
          case GetByGuid.HTTP404         => Status(404)(play.api.mvc.Results.EmptyContent())
          case r: GetByGuid.Undocumented => r.result
        }(defaultExecutionContext)
  }

}

trait MembershipsController extends play.api.mvc.BaseController {

  sealed trait Get extends Product with Serializable
  object Get {
    final case class HTTP200(body: Seq[io.apibuilder.api.v0.models.Membership]) extends Get
    final case class Undocumented(result: play.api.mvc.Result) extends Get
  }

  def get(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      orgGuid: _root_.scala.Option[_root_.java.util.UUID],
      orgKey: _root_.scala.Option[String],
      userGuid: _root_.scala.Option[_root_.java.util.UUID],
      role: _root_.scala.Option[io.apibuilder.common.v0.models.MembershipRole],
      limit: Long,
      offset: Long
  ): scala.concurrent.Future[Get]
  final def get(
      orgGuid: _root_.scala.Option[_root_.java.util.UUID],
      orgKey: _root_.scala.Option[String],
      userGuid: _root_.scala.Option[_root_.java.util.UUID],
      role: _root_.scala.Option[io.apibuilder.common.v0.models.MembershipRole],
      limit: Long,
      offset: Long
  ): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async { request =>
    get(request, orgGuid, orgKey, userGuid, role, limit, offset)
      .map {
        case r: Get.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
        case r: Get.Undocumented => r.result
      }(defaultExecutionContext)
  }

  sealed trait GetByGuid extends Product with Serializable
  object GetByGuid {
    final case class HTTP200(body: io.apibuilder.api.v0.models.Membership) extends GetByGuid
    case object HTTP404 extends GetByGuid
    final case class Undocumented(result: play.api.mvc.Result) extends GetByGuid
  }

  def getByGuid(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      guid: _root_.java.util.UUID
  ): scala.concurrent.Future[GetByGuid]
  final def getByGuid(guid: _root_.java.util.UUID): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async {
    request =>
      getByGuid(request, guid)
        .map {
          case r: GetByGuid.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
          case GetByGuid.HTTP404         => Status(404)(play.api.mvc.Results.EmptyContent())
          case r: GetByGuid.Undocumented => r.result
        }(defaultExecutionContext)
  }

  sealed trait DeleteByGuid extends Product with Serializable
  object DeleteByGuid {
    case object HTTP204 extends DeleteByGuid
    case object HTTP401 extends DeleteByGuid
    case object HTTP404 extends DeleteByGuid
    final case class Undocumented(result: play.api.mvc.Result) extends DeleteByGuid
  }

  def deleteByGuid(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      guid: _root_.java.util.UUID
  ): scala.concurrent.Future[DeleteByGuid]
  final def deleteByGuid(guid: _root_.java.util.UUID): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async {
    request =>
      deleteByGuid(request, guid)
        .map {
          case DeleteByGuid.HTTP204         => Status(204)(play.api.mvc.Results.EmptyContent())
          case DeleteByGuid.HTTP401         => Status(401)(play.api.mvc.Results.EmptyContent())
          case DeleteByGuid.HTTP404         => Status(404)(play.api.mvc.Results.EmptyContent())
          case r: DeleteByGuid.Undocumented => r.result
        }(defaultExecutionContext)
  }

}

trait MembershipRequestsController extends play.api.mvc.BaseController {

  sealed trait Get extends Product with Serializable
  object Get {
    final case class HTTP200(body: Seq[io.apibuilder.api.v0.models.MembershipRequest]) extends Get
    final case class Undocumented(result: play.api.mvc.Result) extends Get
  }

  def get(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      orgGuid: _root_.scala.Option[_root_.java.util.UUID],
      orgKey: _root_.scala.Option[String],
      userGuid: _root_.scala.Option[_root_.java.util.UUID],
      role: _root_.scala.Option[io.apibuilder.common.v0.models.MembershipRole],
      limit: Long,
      offset: Long
  ): scala.concurrent.Future[Get]
  final def get(
      orgGuid: _root_.scala.Option[_root_.java.util.UUID],
      orgKey: _root_.scala.Option[String],
      userGuid: _root_.scala.Option[_root_.java.util.UUID],
      role: _root_.scala.Option[io.apibuilder.common.v0.models.MembershipRole],
      limit: Long,
      offset: Long
  ): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async { request =>
    get(request, orgGuid, orgKey, userGuid, role, limit, offset)
      .map {
        case r: Get.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
        case r: Get.Undocumented => r.result
      }(defaultExecutionContext)
  }

  sealed trait Post extends Product with Serializable
  object Post {
    final case class HTTP200(body: io.apibuilder.api.v0.models.MembershipRequest) extends Post
    final case class HTTP409(body: Seq[io.apibuilder.api.v0.models.Error]) extends Post
    final case class Undocumented(result: play.api.mvc.Result) extends Post
  }

  def post(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      orgGuid: _root_.java.util.UUID,
      userGuid: _root_.java.util.UUID,
      role: io.apibuilder.common.v0.models.MembershipRole
  ): scala.concurrent.Future[Post]
  final def post(
      orgGuid: _root_.java.util.UUID,
      userGuid: _root_.java.util.UUID,
      role: io.apibuilder.common.v0.models.MembershipRole
  ): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async { request =>
    post(request, orgGuid, userGuid, role)
      .map {
        case r: Post.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
        case r: Post.HTTP409      => Status(409)(play.api.libs.json.Json.toJson(r.body))
        case r: Post.Undocumented => r.result
      }(defaultExecutionContext)
  }

  sealed trait PostAcceptByGuid extends Product with Serializable
  object PostAcceptByGuid {
    case object HTTP204 extends PostAcceptByGuid
    final case class HTTP409(body: Seq[io.apibuilder.api.v0.models.Error]) extends PostAcceptByGuid
    final case class Undocumented(result: play.api.mvc.Result) extends PostAcceptByGuid
  }

  def postAcceptByGuid(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      guid: _root_.java.util.UUID
  ): scala.concurrent.Future[PostAcceptByGuid]
  final def postAcceptByGuid(guid: _root_.java.util.UUID): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async {
    request =>
      postAcceptByGuid(request, guid)
        .map {
          case PostAcceptByGuid.HTTP204         => Status(204)(play.api.mvc.Results.EmptyContent())
          case r: PostAcceptByGuid.HTTP409      => Status(409)(play.api.libs.json.Json.toJson(r.body))
          case r: PostAcceptByGuid.Undocumented => r.result
        }(defaultExecutionContext)
  }

  sealed trait PostDeclineByGuid extends Product with Serializable
  object PostDeclineByGuid {
    case object HTTP204 extends PostDeclineByGuid
    final case class HTTP409(body: Seq[io.apibuilder.api.v0.models.Error]) extends PostDeclineByGuid
    final case class Undocumented(result: play.api.mvc.Result) extends PostDeclineByGuid
  }

  def postDeclineByGuid(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      guid: _root_.java.util.UUID
  ): scala.concurrent.Future[PostDeclineByGuid]
  final def postDeclineByGuid(guid: _root_.java.util.UUID): play.api.mvc.Action[play.api.mvc.AnyContent] =
    Action.async { request =>
      postDeclineByGuid(request, guid)
        .map {
          case PostDeclineByGuid.HTTP204         => Status(204)(play.api.mvc.Results.EmptyContent())
          case r: PostDeclineByGuid.HTTP409      => Status(409)(play.api.libs.json.Json.toJson(r.body))
          case r: PostDeclineByGuid.Undocumented => r.result
        }(defaultExecutionContext)
    }

}

trait OrganizationsController extends play.api.mvc.BaseController {

  sealed trait Get extends Product with Serializable
  object Get {
    final case class HTTP200(body: Seq[io.apibuilder.api.v0.models.Organization]) extends Get
    final case class Undocumented(result: play.api.mvc.Result) extends Get
  }

  def get(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      guid: _root_.scala.Option[_root_.java.util.UUID],
      userGuid: _root_.scala.Option[_root_.java.util.UUID],
      key: _root_.scala.Option[String],
      name: _root_.scala.Option[String],
      namespace: _root_.scala.Option[String],
      limit: Long,
      offset: Long
  ): scala.concurrent.Future[Get]
  final def get(
      guid: _root_.scala.Option[_root_.java.util.UUID],
      userGuid: _root_.scala.Option[_root_.java.util.UUID],
      key: _root_.scala.Option[String],
      name: _root_.scala.Option[String],
      namespace: _root_.scala.Option[String],
      limit: Long,
      offset: Long
  ): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async { request =>
    get(request, guid, userGuid, key, name, namespace, limit, offset)
      .map {
        case r: Get.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
        case r: Get.Undocumented => r.result
      }(defaultExecutionContext)
  }

  sealed trait GetByKey extends Product with Serializable
  object GetByKey {
    final case class HTTP200(body: io.apibuilder.api.v0.models.Organization) extends GetByKey
    case object HTTP404 extends GetByKey
    final case class Undocumented(result: play.api.mvc.Result) extends GetByKey
  }

  def getByKey(request: play.api.mvc.Request[play.api.mvc.AnyContent], key: String): scala.concurrent.Future[GetByKey]
  final def getByKey(key: String): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async { request =>
    getByKey(request, key)
      .map {
        case r: GetByKey.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
        case GetByKey.HTTP404         => Status(404)(play.api.mvc.Results.EmptyContent())
        case r: GetByKey.Undocumented => r.result
      }(defaultExecutionContext)
  }

  sealed trait Post extends Product with Serializable
  object Post {
    final case class HTTP200(body: io.apibuilder.api.v0.models.Organization) extends Post
    final case class HTTP409(body: Seq[io.apibuilder.api.v0.models.Error]) extends Post
    final case class Undocumented(result: play.api.mvc.Result) extends Post
  }

  def post(
      request: play.api.mvc.Request[io.apibuilder.api.v0.models.OrganizationForm],
      body: io.apibuilder.api.v0.models.OrganizationForm
  ): scala.concurrent.Future[Post]
  final def post(): play.api.mvc.Action[io.apibuilder.api.v0.models.OrganizationForm] =
    Action.async(parse.json[io.apibuilder.api.v0.models.OrganizationForm]) { request =>
      post(request, request.body)
        .map {
          case r: Post.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
          case r: Post.HTTP409      => Status(409)(play.api.libs.json.Json.toJson(r.body))
          case r: Post.Undocumented => r.result
        }(defaultExecutionContext)
    }

  sealed trait PutByKey extends Product with Serializable
  object PutByKey {
    final case class HTTP200(body: io.apibuilder.api.v0.models.Organization) extends PutByKey
    final case class HTTP409(body: Seq[io.apibuilder.api.v0.models.Error]) extends PutByKey
    final case class Undocumented(result: play.api.mvc.Result) extends PutByKey
  }

  def putByKey(
      request: play.api.mvc.Request[io.apibuilder.api.v0.models.OrganizationForm],
      key: String,
      body: io.apibuilder.api.v0.models.OrganizationForm
  ): scala.concurrent.Future[PutByKey]
  final def putByKey(key: String): play.api.mvc.Action[io.apibuilder.api.v0.models.OrganizationForm] =
    Action.async(parse.json[io.apibuilder.api.v0.models.OrganizationForm]) { request =>
      putByKey(request, key, request.body)
        .map {
          case r: PutByKey.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
          case r: PutByKey.HTTP409      => Status(409)(play.api.libs.json.Json.toJson(r.body))
          case r: PutByKey.Undocumented => r.result
        }(defaultExecutionContext)
    }

  sealed trait DeleteByKey extends Product with Serializable
  object DeleteByKey {
    case object HTTP204 extends DeleteByKey
    case object HTTP401 extends DeleteByKey
    case object HTTP404 extends DeleteByKey
    final case class Undocumented(result: play.api.mvc.Result) extends DeleteByKey
  }

  def deleteByKey(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      key: String
  ): scala.concurrent.Future[DeleteByKey]
  final def deleteByKey(key: String): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async { request =>
    deleteByKey(request, key)
      .map {
        case DeleteByKey.HTTP204         => Status(204)(play.api.mvc.Results.EmptyContent())
        case DeleteByKey.HTTP401         => Status(401)(play.api.mvc.Results.EmptyContent())
        case DeleteByKey.HTTP404         => Status(404)(play.api.mvc.Results.EmptyContent())
        case r: DeleteByKey.Undocumented => r.result
      }(defaultExecutionContext)
  }

  sealed trait GetAttributesByKey extends Product with Serializable
  object GetAttributesByKey {
    final case class HTTP200(body: Seq[io.apibuilder.api.v0.models.AttributeValue]) extends GetAttributesByKey
    final case class Undocumented(result: play.api.mvc.Result) extends GetAttributesByKey
  }

  def getAttributesByKey(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      key: String,
      name: _root_.scala.Option[String],
      limit: Long,
      offset: Long
  ): scala.concurrent.Future[GetAttributesByKey]
  final def getAttributesByKey(
      key: String,
      name: _root_.scala.Option[String],
      limit: Long,
      offset: Long
  ): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async { request =>
    getAttributesByKey(request, key, name, limit, offset)
      .map {
        case r: GetAttributesByKey.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
        case r: GetAttributesByKey.Undocumented => r.result
      }(defaultExecutionContext)
  }

  sealed trait GetAttributesByKeyAndName extends Product with Serializable
  object GetAttributesByKeyAndName {
    final case class HTTP200(body: io.apibuilder.api.v0.models.AttributeValue) extends GetAttributesByKeyAndName
    case object HTTP404 extends GetAttributesByKeyAndName
    final case class Undocumented(result: play.api.mvc.Result) extends GetAttributesByKeyAndName
  }

  def getAttributesByKeyAndName(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      key: String,
      name: String
  ): scala.concurrent.Future[GetAttributesByKeyAndName]
  final def getAttributesByKeyAndName(key: String, name: String): play.api.mvc.Action[play.api.mvc.AnyContent] =
    Action.async { request =>
      getAttributesByKeyAndName(request, key, name)
        .map {
          case r: GetAttributesByKeyAndName.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
          case GetAttributesByKeyAndName.HTTP404         => Status(404)(play.api.mvc.Results.EmptyContent())
          case r: GetAttributesByKeyAndName.Undocumented => r.result
        }(defaultExecutionContext)
    }

  sealed trait PutAttributesByKeyAndName extends Product with Serializable
  object PutAttributesByKeyAndName {
    final case class HTTP200(body: io.apibuilder.api.v0.models.AttributeValue) extends PutAttributesByKeyAndName
    final case class HTTP201(body: io.apibuilder.api.v0.models.AttributeValue) extends PutAttributesByKeyAndName
    case object HTTP404 extends PutAttributesByKeyAndName
    final case class HTTP409(body: Seq[io.apibuilder.api.v0.models.Error]) extends PutAttributesByKeyAndName
    final case class Undocumented(result: play.api.mvc.Result) extends PutAttributesByKeyAndName
  }

  def putAttributesByKeyAndName(
      request: play.api.mvc.Request[io.apibuilder.api.v0.models.AttributeValueForm],
      key: String,
      name: String,
      body: io.apibuilder.api.v0.models.AttributeValueForm
  ): scala.concurrent.Future[PutAttributesByKeyAndName]
  final def putAttributesByKeyAndName(
      key: String,
      name: String
  ): play.api.mvc.Action[io.apibuilder.api.v0.models.AttributeValueForm] =
    Action.async(parse.json[io.apibuilder.api.v0.models.AttributeValueForm]) { request =>
      putAttributesByKeyAndName(request, key, name, request.body)
        .map {
          case r: PutAttributesByKeyAndName.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
          case r: PutAttributesByKeyAndName.HTTP201      => Status(201)(play.api.libs.json.Json.toJson(r.body))
          case PutAttributesByKeyAndName.HTTP404         => Status(404)(play.api.mvc.Results.EmptyContent())
          case r: PutAttributesByKeyAndName.HTTP409      => Status(409)(play.api.libs.json.Json.toJson(r.body))
          case r: PutAttributesByKeyAndName.Undocumented => r.result
        }(defaultExecutionContext)
    }

  sealed trait DeleteAttributesByKeyAndName extends Product with Serializable
  object DeleteAttributesByKeyAndName {
    case object HTTP204 extends DeleteAttributesByKeyAndName
    case object HTTP401 extends DeleteAttributesByKeyAndName
    case object HTTP404 extends DeleteAttributesByKeyAndName
    final case class Undocumented(result: play.api.mvc.Result) extends DeleteAttributesByKeyAndName
  }

  def deleteAttributesByKeyAndName(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      key: String,
      name: String
  ): scala.concurrent.Future[DeleteAttributesByKeyAndName]
  final def deleteAttributesByKeyAndName(key: String, name: String): play.api.mvc.Action[play.api.mvc.AnyContent] =
    Action.async { request =>
      deleteAttributesByKeyAndName(request, key, name)
        .map {
          case DeleteAttributesByKeyAndName.HTTP204         => Status(204)(play.api.mvc.Results.EmptyContent())
          case DeleteAttributesByKeyAndName.HTTP401         => Status(401)(play.api.mvc.Results.EmptyContent())
          case DeleteAttributesByKeyAndName.HTTP404         => Status(404)(play.api.mvc.Results.EmptyContent())
          case r: DeleteAttributesByKeyAndName.Undocumented => r.result
        }(defaultExecutionContext)
    }

}

trait PasswordResetsController extends play.api.mvc.BaseController {

  sealed trait Post extends Product with Serializable
  object Post {
    final case class HTTP200(body: io.apibuilder.api.v0.models.Authentication) extends Post
    final case class HTTP409(body: Seq[io.apibuilder.api.v0.models.Error]) extends Post
    final case class Undocumented(result: play.api.mvc.Result) extends Post
  }

  def post(
      request: play.api.mvc.Request[io.apibuilder.api.v0.models.PasswordReset],
      body: io.apibuilder.api.v0.models.PasswordReset
  ): scala.concurrent.Future[Post]
  final def post(): play.api.mvc.Action[io.apibuilder.api.v0.models.PasswordReset] =
    Action.async(parse.json[io.apibuilder.api.v0.models.PasswordReset]) { request =>
      post(request, request.body)
        .map {
          case r: Post.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
          case r: Post.HTTP409      => Status(409)(play.api.libs.json.Json.toJson(r.body))
          case r: Post.Undocumented => r.result
        }(defaultExecutionContext)
    }

}

trait PasswordResetRequestsController extends play.api.mvc.BaseController {

  sealed trait Post extends Product with Serializable
  object Post {
    case object HTTP204 extends Post
    final case class HTTP409(body: Seq[io.apibuilder.api.v0.models.Error]) extends Post
    final case class Undocumented(result: play.api.mvc.Result) extends Post
  }

  def post(
      request: play.api.mvc.Request[io.apibuilder.api.v0.models.PasswordResetRequest],
      body: io.apibuilder.api.v0.models.PasswordResetRequest
  ): scala.concurrent.Future[Post]
  final def post(): play.api.mvc.Action[io.apibuilder.api.v0.models.PasswordResetRequest] =
    Action.async(parse.json[io.apibuilder.api.v0.models.PasswordResetRequest]) { request =>
      post(request, request.body)
        .map {
          case Post.HTTP204         => Status(204)(play.api.mvc.Results.EmptyContent())
          case r: Post.HTTP409      => Status(409)(play.api.libs.json.Json.toJson(r.body))
          case r: Post.Undocumented => r.result
        }(defaultExecutionContext)
    }

}

trait SubscriptionsController extends play.api.mvc.BaseController {

  sealed trait Get extends Product with Serializable
  object Get {
    final case class HTTP200(body: Seq[io.apibuilder.api.v0.models.Subscription]) extends Get
    final case class Undocumented(result: play.api.mvc.Result) extends Get
  }

  def get(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      guid: _root_.scala.Option[_root_.java.util.UUID],
      organizationKey: _root_.scala.Option[String],
      userGuid: _root_.scala.Option[_root_.java.util.UUID],
      publication: _root_.scala.Option[io.apibuilder.api.v0.models.Publication],
      limit: Long,
      offset: Long
  ): scala.concurrent.Future[Get]
  final def get(
      guid: _root_.scala.Option[_root_.java.util.UUID],
      organizationKey: _root_.scala.Option[String],
      userGuid: _root_.scala.Option[_root_.java.util.UUID],
      publication: _root_.scala.Option[io.apibuilder.api.v0.models.Publication],
      limit: Long,
      offset: Long
  ): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async { request =>
    get(request, guid, organizationKey, userGuid, publication, limit, offset)
      .map {
        case r: Get.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
        case r: Get.Undocumented => r.result
      }(defaultExecutionContext)
  }

  sealed trait GetByGuid extends Product with Serializable
  object GetByGuid {
    final case class HTTP200(body: io.apibuilder.api.v0.models.Subscription) extends GetByGuid
    case object HTTP404 extends GetByGuid
    final case class Undocumented(result: play.api.mvc.Result) extends GetByGuid
  }

  def getByGuid(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      guid: _root_.java.util.UUID
  ): scala.concurrent.Future[GetByGuid]
  final def getByGuid(guid: _root_.java.util.UUID): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async {
    request =>
      getByGuid(request, guid)
        .map {
          case r: GetByGuid.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
          case GetByGuid.HTTP404         => Status(404)(play.api.mvc.Results.EmptyContent())
          case r: GetByGuid.Undocumented => r.result
        }(defaultExecutionContext)
  }

  sealed trait Post extends Product with Serializable
  object Post {
    final case class HTTP201(body: io.apibuilder.api.v0.models.Subscription) extends Post
    final case class HTTP409(body: Seq[io.apibuilder.api.v0.models.Error]) extends Post
    final case class Undocumented(result: play.api.mvc.Result) extends Post
  }

  def post(
      request: play.api.mvc.Request[io.apibuilder.api.v0.models.SubscriptionForm],
      body: io.apibuilder.api.v0.models.SubscriptionForm
  ): scala.concurrent.Future[Post]
  final def post(): play.api.mvc.Action[io.apibuilder.api.v0.models.SubscriptionForm] =
    Action.async(parse.json[io.apibuilder.api.v0.models.SubscriptionForm]) { request =>
      post(request, request.body)
        .map {
          case r: Post.HTTP201      => Status(201)(play.api.libs.json.Json.toJson(r.body))
          case r: Post.HTTP409      => Status(409)(play.api.libs.json.Json.toJson(r.body))
          case r: Post.Undocumented => r.result
        }(defaultExecutionContext)
    }

  sealed trait DeleteByGuid extends Product with Serializable
  object DeleteByGuid {
    case object HTTP204 extends DeleteByGuid
    case object HTTP401 extends DeleteByGuid
    case object HTTP404 extends DeleteByGuid
    final case class Undocumented(result: play.api.mvc.Result) extends DeleteByGuid
  }

  def deleteByGuid(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      guid: _root_.java.util.UUID
  ): scala.concurrent.Future[DeleteByGuid]
  final def deleteByGuid(guid: _root_.java.util.UUID): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async {
    request =>
      deleteByGuid(request, guid)
        .map {
          case DeleteByGuid.HTTP204         => Status(204)(play.api.mvc.Results.EmptyContent())
          case DeleteByGuid.HTTP401         => Status(401)(play.api.mvc.Results.EmptyContent())
          case DeleteByGuid.HTTP404         => Status(404)(play.api.mvc.Results.EmptyContent())
          case r: DeleteByGuid.Undocumented => r.result
        }(defaultExecutionContext)
  }

}

trait TokensController extends play.api.mvc.BaseController {

  sealed trait GetUsersByUserGuid extends Product with Serializable
  object GetUsersByUserGuid {
    final case class HTTP200(body: Seq[io.apibuilder.api.v0.models.Token]) extends GetUsersByUserGuid
    final case class Undocumented(result: play.api.mvc.Result) extends GetUsersByUserGuid
  }

  def getUsersByUserGuid(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      userGuid: _root_.java.util.UUID,
      guid: _root_.scala.Option[_root_.java.util.UUID],
      limit: Long,
      offset: Long
  ): scala.concurrent.Future[GetUsersByUserGuid]
  final def getUsersByUserGuid(
      userGuid: _root_.java.util.UUID,
      guid: _root_.scala.Option[_root_.java.util.UUID],
      limit: Long,
      offset: Long
  ): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async { request =>
    getUsersByUserGuid(request, userGuid, guid, limit, offset)
      .map {
        case r: GetUsersByUserGuid.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
        case r: GetUsersByUserGuid.Undocumented => r.result
      }(defaultExecutionContext)
  }

  sealed trait GetCleartextByGuid extends Product with Serializable
  object GetCleartextByGuid {
    final case class HTTP200(body: io.apibuilder.api.v0.models.CleartextToken) extends GetCleartextByGuid
    case object HTTP404 extends GetCleartextByGuid
    final case class Undocumented(result: play.api.mvc.Result) extends GetCleartextByGuid
  }

  def getCleartextByGuid(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      guid: _root_.java.util.UUID
  ): scala.concurrent.Future[GetCleartextByGuid]
  final def getCleartextByGuid(guid: _root_.java.util.UUID): play.api.mvc.Action[play.api.mvc.AnyContent] =
    Action.async { request =>
      getCleartextByGuid(request, guid)
        .map {
          case r: GetCleartextByGuid.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
          case GetCleartextByGuid.HTTP404         => Status(404)(play.api.mvc.Results.EmptyContent())
          case r: GetCleartextByGuid.Undocumented => r.result
        }(defaultExecutionContext)
    }

  sealed trait Post extends Product with Serializable
  object Post {
    final case class HTTP201(body: io.apibuilder.api.v0.models.Token) extends Post
    final case class HTTP409(body: Seq[io.apibuilder.api.v0.models.Error]) extends Post
    final case class Undocumented(result: play.api.mvc.Result) extends Post
  }

  def post(
      request: play.api.mvc.Request[io.apibuilder.api.v0.models.TokenForm],
      body: io.apibuilder.api.v0.models.TokenForm
  ): scala.concurrent.Future[Post]
  final def post(): play.api.mvc.Action[io.apibuilder.api.v0.models.TokenForm] =
    Action.async(parse.json[io.apibuilder.api.v0.models.TokenForm]) { request =>
      post(request, request.body)
        .map {
          case r: Post.HTTP201      => Status(201)(play.api.libs.json.Json.toJson(r.body))
          case r: Post.HTTP409      => Status(409)(play.api.libs.json.Json.toJson(r.body))
          case r: Post.Undocumented => r.result
        }(defaultExecutionContext)
    }

  sealed trait DeleteByGuid extends Product with Serializable
  object DeleteByGuid {
    case object HTTP204 extends DeleteByGuid
    case object HTTP401 extends DeleteByGuid
    case object HTTP404 extends DeleteByGuid
    final case class Undocumented(result: play.api.mvc.Result) extends DeleteByGuid
  }

  def deleteByGuid(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      guid: _root_.java.util.UUID
  ): scala.concurrent.Future[DeleteByGuid]
  final def deleteByGuid(guid: _root_.java.util.UUID): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async {
    request =>
      deleteByGuid(request, guid)
        .map {
          case DeleteByGuid.HTTP204         => Status(204)(play.api.mvc.Results.EmptyContent())
          case DeleteByGuid.HTTP401         => Status(401)(play.api.mvc.Results.EmptyContent())
          case DeleteByGuid.HTTP404         => Status(404)(play.api.mvc.Results.EmptyContent())
          case r: DeleteByGuid.Undocumented => r.result
        }(defaultExecutionContext)
  }

}

trait UsersController extends play.api.mvc.BaseController {

  sealed trait Get extends Product with Serializable
  object Get {
    final case class HTTP200(body: Seq[io.apibuilder.api.v0.models.User]) extends Get
    final case class Undocumented(result: play.api.mvc.Result) extends Get
  }

  def get(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      guid: _root_.scala.Option[_root_.java.util.UUID],
      email: _root_.scala.Option[String],
      nickname: _root_.scala.Option[String],
      token: _root_.scala.Option[String]
  ): scala.concurrent.Future[Get]
  final def get(
      guid: _root_.scala.Option[_root_.java.util.UUID],
      email: _root_.scala.Option[String],
      nickname: _root_.scala.Option[String],
      token: _root_.scala.Option[String]
  ): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async { request =>
    get(request, guid, email, nickname, token)
      .map {
        case r: Get.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
        case r: Get.Undocumented => r.result
      }(defaultExecutionContext)
  }

  sealed trait GetByGuid extends Product with Serializable
  object GetByGuid {
    final case class HTTP200(body: io.apibuilder.api.v0.models.User) extends GetByGuid
    case object HTTP404 extends GetByGuid
    final case class Undocumented(result: play.api.mvc.Result) extends GetByGuid
  }

  def getByGuid(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      guid: _root_.java.util.UUID
  ): scala.concurrent.Future[GetByGuid]
  final def getByGuid(guid: _root_.java.util.UUID): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async {
    request =>
      getByGuid(request, guid)
        .map {
          case r: GetByGuid.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
          case GetByGuid.HTTP404         => Status(404)(play.api.mvc.Results.EmptyContent())
          case r: GetByGuid.Undocumented => r.result
        }(defaultExecutionContext)
  }

  sealed trait PostAuthenticate extends Product with Serializable
  object PostAuthenticate {
    final case class HTTP200(body: io.apibuilder.api.v0.models.Authentication) extends PostAuthenticate
    final case class HTTP409(body: Seq[io.apibuilder.api.v0.models.Error]) extends PostAuthenticate
    final case class Undocumented(result: play.api.mvc.Result) extends PostAuthenticate
  }

  def postAuthenticate(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      email: String,
      password: String
  ): scala.concurrent.Future[PostAuthenticate]
  final def postAuthenticate(email: String, password: String): play.api.mvc.Action[play.api.mvc.AnyContent] =
    Action.async { request =>
      postAuthenticate(request, email, password)
        .map {
          case r: PostAuthenticate.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
          case r: PostAuthenticate.HTTP409      => Status(409)(play.api.libs.json.Json.toJson(r.body))
          case r: PostAuthenticate.Undocumented => r.result
        }(defaultExecutionContext)
    }

  sealed trait PostAuthenticateGithub extends Product with Serializable
  object PostAuthenticateGithub {
    final case class HTTP200(body: io.apibuilder.api.v0.models.Authentication) extends PostAuthenticateGithub
    final case class HTTP409(body: Seq[io.apibuilder.api.v0.models.Error]) extends PostAuthenticateGithub
    final case class Undocumented(result: play.api.mvc.Result) extends PostAuthenticateGithub
  }

  def postAuthenticateGithub(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      token: String
  ): scala.concurrent.Future[PostAuthenticateGithub]
  final def postAuthenticateGithub(token: String): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async {
    request =>
      postAuthenticateGithub(request, token)
        .map {
          case r: PostAuthenticateGithub.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
          case r: PostAuthenticateGithub.HTTP409      => Status(409)(play.api.libs.json.Json.toJson(r.body))
          case r: PostAuthenticateGithub.Undocumented => r.result
        }(defaultExecutionContext)
  }

  sealed trait Post extends Product with Serializable
  object Post {
    final case class HTTP200(body: io.apibuilder.api.v0.models.User) extends Post
    final case class HTTP409(body: Seq[io.apibuilder.api.v0.models.Error]) extends Post
    final case class Undocumented(result: play.api.mvc.Result) extends Post
  }

  def post(
      request: play.api.mvc.Request[io.apibuilder.api.v0.models.UserForm],
      body: io.apibuilder.api.v0.models.UserForm
  ): scala.concurrent.Future[Post]
  final def post(): play.api.mvc.Action[io.apibuilder.api.v0.models.UserForm] =
    Action.async(parse.json[io.apibuilder.api.v0.models.UserForm]) { request =>
      post(request, request.body)
        .map {
          case r: Post.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
          case r: Post.HTTP409      => Status(409)(play.api.libs.json.Json.toJson(r.body))
          case r: Post.Undocumented => r.result
        }(defaultExecutionContext)
    }

  sealed trait PutByGuid extends Product with Serializable
  object PutByGuid {
    final case class HTTP200(body: io.apibuilder.api.v0.models.User) extends PutByGuid
    final case class HTTP409(body: Seq[io.apibuilder.api.v0.models.Error]) extends PutByGuid
    final case class Undocumented(result: play.api.mvc.Result) extends PutByGuid
  }

  def putByGuid(
      request: play.api.mvc.Request[io.apibuilder.api.v0.models.UserUpdateForm],
      guid: _root_.java.util.UUID,
      body: io.apibuilder.api.v0.models.UserUpdateForm
  ): scala.concurrent.Future[PutByGuid]
  final def putByGuid(guid: _root_.java.util.UUID): play.api.mvc.Action[io.apibuilder.api.v0.models.UserUpdateForm] =
    Action.async(parse.json[io.apibuilder.api.v0.models.UserUpdateForm]) { request =>
      putByGuid(request, guid, request.body)
        .map {
          case r: PutByGuid.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
          case r: PutByGuid.HTTP409      => Status(409)(play.api.libs.json.Json.toJson(r.body))
          case r: PutByGuid.Undocumented => r.result
        }(defaultExecutionContext)
    }

}

trait ValidationsController extends play.api.mvc.BaseController {

  sealed trait Post extends Product with Serializable
  object Post {
    final case class HTTP200(body: io.apibuilder.api.v0.models.Validation) extends Post
    final case class Undocumented(result: play.api.mvc.Result) extends Post
  }

  def post(request: play.api.mvc.Request[String], body: String): scala.concurrent.Future[Post]
  final def post(): play.api.mvc.Action[String] = Action.async(parse.json[String]) { request =>
    post(request, request.body)
      .map {
        case r: Post.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
        case r: Post.Undocumented => r.result
      }(defaultExecutionContext)
  }

}

trait VersionsController extends play.api.mvc.BaseController {

  sealed trait GetByApplicationKey extends Product with Serializable
  object GetByApplicationKey {
    final case class HTTP200(body: Seq[io.apibuilder.api.v0.models.Version]) extends GetByApplicationKey
    final case class Undocumented(result: play.api.mvc.Result) extends GetByApplicationKey
  }

  def getByApplicationKey(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      orgKey: String,
      applicationKey: String,
      limit: Long,
      offset: Long
  ): scala.concurrent.Future[GetByApplicationKey]
  final def getByApplicationKey(
      orgKey: String,
      applicationKey: String,
      limit: Long,
      offset: Long
  ): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async { request =>
    getByApplicationKey(request, orgKey, applicationKey, limit, offset)
      .map {
        case r: GetByApplicationKey.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
        case r: GetByApplicationKey.Undocumented => r.result
      }(defaultExecutionContext)
  }

  sealed trait GetByApplicationKeyAndVersion extends Product with Serializable
  object GetByApplicationKeyAndVersion {
    final case class HTTP200(body: io.apibuilder.api.v0.models.Version) extends GetByApplicationKeyAndVersion
    case object HTTP404 extends GetByApplicationKeyAndVersion
    final case class Undocumented(result: play.api.mvc.Result) extends GetByApplicationKeyAndVersion
  }

  def getByApplicationKeyAndVersion(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      orgKey: String,
      applicationKey: String,
      version: String
  ): scala.concurrent.Future[GetByApplicationKeyAndVersion]
  final def getByApplicationKeyAndVersion(
      orgKey: String,
      applicationKey: String,
      version: String
  ): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async { request =>
    getByApplicationKeyAndVersion(request, orgKey, applicationKey, version)
      .map {
        case r: GetByApplicationKeyAndVersion.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
        case GetByApplicationKeyAndVersion.HTTP404         => Status(404)(play.api.mvc.Results.EmptyContent())
        case r: GetByApplicationKeyAndVersion.Undocumented => r.result
      }(defaultExecutionContext)
  }

  sealed trait PostByVersion extends Product with Serializable
  object PostByVersion {
    final case class HTTP200(body: io.apibuilder.api.v0.models.Version) extends PostByVersion
    final case class HTTP409(body: Seq[io.apibuilder.api.v0.models.Error]) extends PostByVersion
    final case class Undocumented(result: play.api.mvc.Result) extends PostByVersion
  }

  def postByVersion(
      request: play.api.mvc.Request[io.apibuilder.api.v0.models.VersionForm],
      orgKey: String,
      version: String,
      body: io.apibuilder.api.v0.models.VersionForm
  ): scala.concurrent.Future[PostByVersion]
  final def postByVersion(
      orgKey: String,
      version: String
  ): play.api.mvc.Action[io.apibuilder.api.v0.models.VersionForm] =
    Action.async(parse.json[io.apibuilder.api.v0.models.VersionForm]) { request =>
      postByVersion(request, orgKey, version, request.body)
        .map {
          case r: PostByVersion.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
          case r: PostByVersion.HTTP409      => Status(409)(play.api.libs.json.Json.toJson(r.body))
          case r: PostByVersion.Undocumented => r.result
        }(defaultExecutionContext)
    }

  sealed trait PutByApplicationKeyAndVersion extends Product with Serializable
  object PutByApplicationKeyAndVersion {
    final case class HTTP200(body: io.apibuilder.api.v0.models.Version) extends PutByApplicationKeyAndVersion
    final case class HTTP409(body: Seq[io.apibuilder.api.v0.models.Error]) extends PutByApplicationKeyAndVersion
    final case class Undocumented(result: play.api.mvc.Result) extends PutByApplicationKeyAndVersion
  }

  def putByApplicationKeyAndVersion(
      request: play.api.mvc.Request[io.apibuilder.api.v0.models.VersionForm],
      orgKey: String,
      applicationKey: String,
      version: String,
      body: io.apibuilder.api.v0.models.VersionForm
  ): scala.concurrent.Future[PutByApplicationKeyAndVersion]
  final def putByApplicationKeyAndVersion(
      orgKey: String,
      applicationKey: String,
      version: String
  ): play.api.mvc.Action[io.apibuilder.api.v0.models.VersionForm] =
    Action.async(parse.json[io.apibuilder.api.v0.models.VersionForm]) { request =>
      putByApplicationKeyAndVersion(request, orgKey, applicationKey, version, request.body)
        .map {
          case r: PutByApplicationKeyAndVersion.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
          case r: PutByApplicationKeyAndVersion.HTTP409      => Status(409)(play.api.libs.json.Json.toJson(r.body))
          case r: PutByApplicationKeyAndVersion.Undocumented => r.result
        }(defaultExecutionContext)
    }

  sealed trait DeleteByApplicationKeyAndVersion extends Product with Serializable
  object DeleteByApplicationKeyAndVersion {
    case object HTTP204 extends DeleteByApplicationKeyAndVersion
    case object HTTP401 extends DeleteByApplicationKeyAndVersion
    case object HTTP404 extends DeleteByApplicationKeyAndVersion
    final case class Undocumented(result: play.api.mvc.Result) extends DeleteByApplicationKeyAndVersion
  }

  def deleteByApplicationKeyAndVersion(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      orgKey: String,
      applicationKey: String,
      version: String
  ): scala.concurrent.Future[DeleteByApplicationKeyAndVersion]
  final def deleteByApplicationKeyAndVersion(
      orgKey: String,
      applicationKey: String,
      version: String
  ): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async { request =>
    deleteByApplicationKeyAndVersion(request, orgKey, applicationKey, version)
      .map {
        case DeleteByApplicationKeyAndVersion.HTTP204         => Status(204)(play.api.mvc.Results.EmptyContent())
        case DeleteByApplicationKeyAndVersion.HTTP401         => Status(401)(play.api.mvc.Results.EmptyContent())
        case DeleteByApplicationKeyAndVersion.HTTP404         => Status(404)(play.api.mvc.Results.EmptyContent())
        case r: DeleteByApplicationKeyAndVersion.Undocumented => r.result
      }(defaultExecutionContext)
  }

  sealed trait GetExampleByApplicationKeyAndVersionAndTypeName extends Product with Serializable
  object GetExampleByApplicationKeyAndVersionAndTypeName {
    final case class HTTP200(body: _root_.play.api.libs.json.JsObject)
        extends GetExampleByApplicationKeyAndVersionAndTypeName
    case object HTTP404 extends GetExampleByApplicationKeyAndVersionAndTypeName
    final case class Undocumented(result: play.api.mvc.Result) extends GetExampleByApplicationKeyAndVersionAndTypeName
  }

  def getExampleByApplicationKeyAndVersionAndTypeName(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      orgKey: String,
      applicationKey: String,
      version: String,
      typeName: String,
      subTypeName: _root_.scala.Option[String],
      optionalFields: _root_.scala.Option[Boolean]
  ): scala.concurrent.Future[GetExampleByApplicationKeyAndVersionAndTypeName]
  final def getExampleByApplicationKeyAndVersionAndTypeName(
      orgKey: String,
      applicationKey: String,
      version: String,
      typeName: String,
      subTypeName: _root_.scala.Option[String],
      optionalFields: _root_.scala.Option[Boolean]
  ): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async { request =>
    getExampleByApplicationKeyAndVersionAndTypeName(
      request,
      orgKey,
      applicationKey,
      version,
      typeName,
      subTypeName,
      optionalFields
    ).map {
        case r: GetExampleByApplicationKeyAndVersionAndTypeName.HTTP200 =>
          Status(200)(play.api.libs.json.Json.toJson(r.body))
        case GetExampleByApplicationKeyAndVersionAndTypeName.HTTP404         => Status(404)(play.api.mvc.Results.EmptyContent())
        case r: GetExampleByApplicationKeyAndVersionAndTypeName.Undocumented => r.result
      }(defaultExecutionContext)
  }

}

trait WatchesController extends play.api.mvc.BaseController {

  sealed trait Get extends Product with Serializable
  object Get {
    final case class HTTP200(body: Seq[io.apibuilder.api.v0.models.Watch]) extends Get
    final case class Undocumented(result: play.api.mvc.Result) extends Get
  }

  def get(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      guid: _root_.scala.Option[_root_.java.util.UUID],
      userGuid: _root_.scala.Option[_root_.java.util.UUID],
      organizationKey: _root_.scala.Option[String],
      applicationKey: _root_.scala.Option[String],
      limit: Long,
      offset: Long
  ): scala.concurrent.Future[Get]
  final def get(
      guid: _root_.scala.Option[_root_.java.util.UUID],
      userGuid: _root_.scala.Option[_root_.java.util.UUID],
      organizationKey: _root_.scala.Option[String],
      applicationKey: _root_.scala.Option[String],
      limit: Long,
      offset: Long
  ): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async { request =>
    get(request, guid, userGuid, organizationKey, applicationKey, limit, offset)
      .map {
        case r: Get.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
        case r: Get.Undocumented => r.result
      }(defaultExecutionContext)
  }

  sealed trait GetByGuid extends Product with Serializable
  object GetByGuid {
    final case class HTTP200(body: io.apibuilder.api.v0.models.Watch) extends GetByGuid
    case object HTTP404 extends GetByGuid
    final case class Undocumented(result: play.api.mvc.Result) extends GetByGuid
  }

  def getByGuid(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      guid: _root_.java.util.UUID
  ): scala.concurrent.Future[GetByGuid]
  final def getByGuid(guid: _root_.java.util.UUID): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async {
    request =>
      getByGuid(request, guid)
        .map {
          case r: GetByGuid.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
          case GetByGuid.HTTP404         => Status(404)(play.api.mvc.Results.EmptyContent())
          case r: GetByGuid.Undocumented => r.result
        }(defaultExecutionContext)
  }

  sealed trait GetCheck extends Product with Serializable
  object GetCheck {
    final case class HTTP200(body: Boolean) extends GetCheck
    final case class Undocumented(result: play.api.mvc.Result) extends GetCheck
  }

  def getCheck(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      userGuid: _root_.scala.Option[_root_.java.util.UUID],
      organizationKey: String,
      applicationKey: String
  ): scala.concurrent.Future[GetCheck]
  final def getCheck(
      userGuid: _root_.scala.Option[_root_.java.util.UUID],
      organizationKey: String,
      applicationKey: String
  ): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async { request =>
    getCheck(request, userGuid, organizationKey, applicationKey)
      .map {
        case r: GetCheck.HTTP200      => Status(200)(play.api.libs.json.Json.toJson(r.body))
        case r: GetCheck.Undocumented => r.result
      }(defaultExecutionContext)
  }

  sealed trait Post extends Product with Serializable
  object Post {
    final case class HTTP201(body: io.apibuilder.api.v0.models.Watch) extends Post
    final case class HTTP409(body: Seq[io.apibuilder.api.v0.models.Error]) extends Post
    final case class Undocumented(result: play.api.mvc.Result) extends Post
  }

  def post(
      request: play.api.mvc.Request[io.apibuilder.api.v0.models.WatchForm],
      body: io.apibuilder.api.v0.models.WatchForm
  ): scala.concurrent.Future[Post]
  final def post(): play.api.mvc.Action[io.apibuilder.api.v0.models.WatchForm] =
    Action.async(parse.json[io.apibuilder.api.v0.models.WatchForm]) { request =>
      post(request, request.body)
        .map {
          case r: Post.HTTP201      => Status(201)(play.api.libs.json.Json.toJson(r.body))
          case r: Post.HTTP409      => Status(409)(play.api.libs.json.Json.toJson(r.body))
          case r: Post.Undocumented => r.result
        }(defaultExecutionContext)
    }

  sealed trait DeleteByGuid extends Product with Serializable
  object DeleteByGuid {
    case object HTTP204 extends DeleteByGuid
    case object HTTP401 extends DeleteByGuid
    case object HTTP404 extends DeleteByGuid
    final case class Undocumented(result: play.api.mvc.Result) extends DeleteByGuid
  }

  def deleteByGuid(
      request: play.api.mvc.Request[play.api.mvc.AnyContent],
      guid: _root_.java.util.UUID
  ): scala.concurrent.Future[DeleteByGuid]
  final def deleteByGuid(guid: _root_.java.util.UUID): play.api.mvc.Action[play.api.mvc.AnyContent] = Action.async {
    request =>
      deleteByGuid(request, guid)
        .map {
          case DeleteByGuid.HTTP204         => Status(204)(play.api.mvc.Results.EmptyContent())
          case DeleteByGuid.HTTP401         => Status(401)(play.api.mvc.Results.EmptyContent())
          case DeleteByGuid.HTTP404         => Status(404)(play.api.mvc.Results.EmptyContent())
          case r: DeleteByGuid.Undocumented => r.result
        }(defaultExecutionContext)
  }

}
