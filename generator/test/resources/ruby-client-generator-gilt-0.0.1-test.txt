# Generated by apidoc - http://www.apidoc.me

require 'cgi'
require 'net/http'
require 'net/https'
require 'uri'
require 'base64'

require 'rubygems'
require 'json'
require 'bigdecimal'

module ApidocReferenceApi

  class Client

    USER_AGENT = 'unknown' unless defined?(USER_AGENT)

    def initialize(url, opts={})
      @url = HttpClient::Preconditions.assert_class('url', url, String)
      @authorization = HttpClient::Preconditions.assert_class_or_nil('authorization', opts.delete(:authorization), HttpClient::Authorization)
      HttpClient::Preconditions.assert_empty_opts(opts)
      HttpClient::Preconditions.check_state(url.match(/http.+/i), "URL[%s] must start with http" % url)
    end

    def request(path=nil)
      HttpClient::Preconditions.assert_class_or_nil('path', path, String)
      request = HttpClient::Request.new(URI.parse(@url + path.to_s)).with_header('User-Agent', USER_AGENT)

      if @authorization
        request.with_auth(@authorization)
      else
        request
      end
    end

    def echoes
      @echoes ||= ApidocReferenceApi::Clients::Echoes.new(self)
    end

    def members
      @members ||= ApidocReferenceApi::Clients::Members.new(self)
    end

    def organizations
      @organizations ||= ApidocReferenceApi::Clients::Organizations.new(self)
    end

    def users
      @users ||= ApidocReferenceApi::Clients::Users.new(self)
    end
  end

  module Clients

    class Echoes

      def initialize(client)
        @client = HttpClient::Preconditions.assert_class('client', client, ApidocReferenceApi::Client)
      end

      def get(incoming={})
        opts = HttpClient::Helper.symbolize_keys(incoming)
        query = {
          :foo => HttpClient::Preconditions.assert_class_or_nil('foo', opts.delete(:foo), String),
          :optional_messages => (opts.delete(:optional_messages) || []).map { |v| HttpClient::Preconditions.assert_class_or_nil('optional_messages', v, String)},
          :required_messages => HttpClient::Preconditions.assert_class('required_messages', opts.delete(:required_messages), Array).map { |v| HttpClient::Preconditions.assert_class('required_messages', v, String)}
        }.delete_if { |k, v| v.nil? }
        @client.request("/echoes").with_query(query).get
        nil
      end

      def get_arrays_only(incoming={})
        opts = HttpClient::Helper.symbolize_keys(incoming)
        query = {
          :optional_messages => (opts.delete(:optional_messages) || []).map { |v| HttpClient::Preconditions.assert_class_or_nil('optional_messages', v, String)},
          :required_messages => HttpClient::Preconditions.assert_class('required_messages', opts.delete(:required_messages), Array).map { |v| HttpClient::Preconditions.assert_class('required_messages', v, String)}
        }.delete_if { |k, v| v.nil? }
        @client.request("/echoes/arrays-only").with_query(query).get
        nil
      end

    end

    class Members

      def initialize(client)
        @client = HttpClient::Preconditions.assert_class('client', client, ApidocReferenceApi::Client)
      end

      def post(hash)
        HttpClient::Preconditions.assert_class('hash', hash, Hash)
        @client.request("/members").with_json(hash.to_json).post { |hash| ApidocReferenceApi::Models::Member.new(hash) }
      end

      def get(incoming={})
        opts = HttpClient::Helper.symbolize_keys(incoming)
        query = {
          :guid => HttpClient::Preconditions.assert_class_or_nil('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String),
          :organization_guid => HttpClient::Preconditions.assert_class_or_nil('organization_guid', HttpClient::Helper.to_uuid(opts.delete(:organization_guid)), String),
          :user_guid => HttpClient::Preconditions.assert_class_or_nil('user_guid', HttpClient::Helper.to_uuid(opts.delete(:user_guid)), String),
          :role => HttpClient::Preconditions.assert_class_or_nil('role', opts.delete(:role), String)
        }.delete_if { |k, v| v.nil? }
        @client.request("/members").with_query(query).get.map { |hash| ApidocReferenceApi::Models::Member.new(hash) }
      end

      def get_by_organization(organization)
        HttpClient::Preconditions.assert_class('organization', organization, String)
        @client.request("/members/#{organization}").get.map { |hash| ApidocReferenceApi::Models::Member.new(hash) }
      end

    end

    class Organizations

      def initialize(client)
        @client = HttpClient::Preconditions.assert_class('client', client, ApidocReferenceApi::Client)
      end

      def post(hash)
        HttpClient::Preconditions.assert_class('hash', hash, Hash)
        @client.request("/organizations").with_json(hash.to_json).post { |hash| ApidocReferenceApi::Models::Organization.new(hash) }
      end

      def get(incoming={})
        opts = HttpClient::Helper.symbolize_keys(incoming)
        query = {
          :guid => HttpClient::Preconditions.assert_class_or_nil('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String),
          :name => HttpClient::Preconditions.assert_class_or_nil('name', opts.delete(:name), String)
        }.delete_if { |k, v| v.nil? }
        @client.request("/organizations").with_query(query).get.map { |hash| ApidocReferenceApi::Models::Organization.new(hash) }
      end

      def get_by_guid(guid)
        HttpClient::Preconditions.assert_class('guid', guid, String)
        @client.request("/#{guid}").get { |hash| ApidocReferenceApi::Models::Organization.new(hash) }
      end

    end

    class Users

      def initialize(client)
        @client = HttpClient::Preconditions.assert_class('client', client, ApidocReferenceApi::Client)
      end

      def post(hash)
        HttpClient::Preconditions.assert_class('hash', hash, Hash)
        @client.request("/users").with_json(hash.to_json).post { |hash| ApidocReferenceApi::Models::User.new(hash) }
      end

      def get(incoming={})
        opts = HttpClient::Helper.symbolize_keys(incoming)
        query = {
          :guid => HttpClient::Preconditions.assert_class_or_nil('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String),
          :organization_guids => (opts.delete(:organization_guids) || []).map { |v| HttpClient::Preconditions.assert_class_or_nil('organization_guids', v, Integer)},
          :age_group => HttpClient::Preconditions.assert_class_or_nil('age_group', opts[:age_group].nil? ? nil : (opts[:age_group].is_a?(ApidocReferenceApi::Models::AgeGroup) ? opts.delete(:age_group) : ApidocReferenceApi::Models::AgeGroup.apply(opts.delete(:age_group))), ApidocReferenceApi::Models::AgeGroup),
          :email => HttpClient::Preconditions.assert_class_or_nil('email', opts.delete(:email), String),
          :active => HttpClient::Preconditions.assert_boolean_or_nil('active', opts.delete(:active))
        }.delete_if { |k, v| v.nil? }
        @client.request("/users").with_query(query).get.map { |hash| ApidocReferenceApi::Models::User.new(hash) }
      end

      def get_by_age_group(age_group)
        HttpClient::Preconditions.assert_class('age_group', age_group, ApidocReferenceApi::Models::AgeGroup)
        @client.request("/users/#{age_group.value}").get.map { |hash| ApidocReferenceApi::Models::User.new(hash) }
      end

      def post_noop(hash)
        HttpClient::Preconditions.assert_class('hash', hash, Hash)
        @client.request("/users/noop").with_json(hash.to_json).post
        nil
      end

    end

  end

  module Models
    class AgeGroup

      attr_reader :value

      def initialize(value)
        @value = HttpClient::Preconditions.assert_class('value', value, String)
      end

      # Returns the instance of AgeGroup for this value, creating a new instance for an unknown value
      def AgeGroup.apply(value)
        if value.instance_of?(AgeGroup)
          value
        else
          HttpClient::Preconditions.assert_class_or_nil('value', value, String)
          value.nil? ? nil : (from_string(value) || AgeGroup.new(value))
        end
      end

      # Returns the instance of AgeGroup for this value, or nil if not found
      def AgeGroup.from_string(value)
        HttpClient::Preconditions.assert_class('value', value, String)
        AgeGroup.ALL.find { |v| v.value == value }
      end

      def AgeGroup.ALL
        @@all ||= [AgeGroup.youth, AgeGroup.adult]
      end

      # under 18
      def AgeGroup.youth
        @@_youth ||= AgeGroup.new('Youth')
      end

      # 18 and over
      def AgeGroup.adult
        @@_adult ||= AgeGroup.new('Adult')
      end

    end

    # A model with a lot of fields.
    class Big

      attr_reader :f1, :f2, :f3, :f4, :f5, :f6, :f7, :f8, :f9, :f10, :f11, :f12, :f13, :f14, :f15, :f16, :f17, :f18, :f19, :f20, :f21

      def initialize(incoming={})
        opts = HttpClient::Helper.symbolize_keys(incoming)
        @f1 = HttpClient::Preconditions.assert_class('f1', opts.delete(:f1), String)
        @f2 = HttpClient::Preconditions.assert_class('f2', opts.delete(:f2), String)
        @f3 = HttpClient::Preconditions.assert_class('f3', opts.delete(:f3), String)
        @f4 = HttpClient::Preconditions.assert_class('f4', opts.delete(:f4), String)
        @f5 = HttpClient::Preconditions.assert_class('f5', opts.delete(:f5), String)
        @f6 = HttpClient::Preconditions.assert_class('f6', opts.delete(:f6), String)
        @f7 = HttpClient::Preconditions.assert_class('f7', opts.delete(:f7), String)
        @f8 = HttpClient::Preconditions.assert_class('f8', opts.delete(:f8), String)
        @f9 = HttpClient::Preconditions.assert_class('f9', opts.delete(:f9), String)
        @f10 = HttpClient::Preconditions.assert_class('f10', opts.delete(:f10), String)
        @f11 = HttpClient::Preconditions.assert_class('f11', opts.delete(:f11), String)
        @f12 = HttpClient::Preconditions.assert_class('f12', opts.delete(:f12), String)
        @f13 = HttpClient::Preconditions.assert_class('f13', opts.delete(:f13), String)
        @f14 = HttpClient::Preconditions.assert_class('f14', opts.delete(:f14), String)
        @f15 = HttpClient::Preconditions.assert_class('f15', opts.delete(:f15), String)
        @f16 = HttpClient::Preconditions.assert_class('f16', opts.delete(:f16), String)
        @f17 = HttpClient::Preconditions.assert_class('f17', opts.delete(:f17), String)
        @f18 = HttpClient::Preconditions.assert_class('f18', opts.delete(:f18), String)
        @f19 = HttpClient::Preconditions.assert_class('f19', opts.delete(:f19), String)
        @f20 = HttpClient::Preconditions.assert_class('f20', opts.delete(:f20), String)
        @f21 = HttpClient::Preconditions.assert_class('f21', opts.delete(:f21), String)
      end

      def to_json
        JSON.dump(to_hash)
      end

      def copy(incoming={})
        Big.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
      end

      def to_hash
        {
          :f1 => f1,
          :f2 => f2,
          :f3 => f3,
          :f4 => f4,
          :f5 => f5,
          :f6 => f6,
          :f7 => f7,
          :f8 => f8,
          :f9 => f9,
          :f10 => f10,
          :f11 => f11,
          :f12 => f12,
          :f13 => f13,
          :f14 => f14,
          :f15 => f15,
          :f16 => f16,
          :f17 => f17,
          :f18 => f18,
          :f19 => f19,
          :f20 => f20,
          :f21 => f21
        }
      end

    end

    class Echo

      attr_reader :value

      def initialize(incoming={})
        opts = HttpClient::Helper.symbolize_keys(incoming)
        @value = HttpClient::Preconditions.assert_class('value', opts.delete(:value), String)
      end

      def to_json
        JSON.dump(to_hash)
      end

      def copy(incoming={})
        Echo.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
      end

      def to_hash
        {
          :value => value
        }
      end

    end

    # Models an API error.
    class Error

      attr_reader :code, :message

      def initialize(incoming={})
        opts = HttpClient::Helper.symbolize_keys(incoming)
        @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
        @message = HttpClient::Preconditions.assert_class('message', opts.delete(:message), String)
      end

      def to_json
        JSON.dump(to_hash)
      end

      def copy(incoming={})
        Error.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
      end

      def to_hash
        {
          :code => code,
          :message => message
        }
      end

    end

    class Member

      attr_reader :guid, :organization, :user, :role

      def initialize(incoming={})
        opts = HttpClient::Helper.symbolize_keys(incoming)
        @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
        @organization = HttpClient::Preconditions.assert_class('organization', opts[:organization].nil? ? nil : (opts[:organization].is_a?(ApidocReferenceApi::Models::Organization) ? opts.delete(:organization) : ApidocReferenceApi::Models::Organization.new(opts.delete(:organization))), ApidocReferenceApi::Models::Organization)
        @user = HttpClient::Preconditions.assert_class('user', opts[:user].nil? ? nil : (opts[:user].is_a?(ApidocReferenceApi::Models::User) ? opts.delete(:user) : ApidocReferenceApi::Models::User.new(opts.delete(:user))), ApidocReferenceApi::Models::User)
        @role = HttpClient::Preconditions.assert_class('role', opts.delete(:role), String)
      end

      def to_json
        JSON.dump(to_hash)
      end

      def copy(incoming={})
        Member.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
      end

      def to_hash
        {
          :guid => guid,
          :organization => organization.nil? ? nil : organization.to_hash,
          :user => user.nil? ? nil : user.to_hash,
          :role => role
        }
      end

    end

    class Organization

      attr_reader :guid, :name

      def initialize(incoming={})
        opts = HttpClient::Helper.symbolize_keys(incoming)
        @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
        @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
      end

      def to_json
        JSON.dump(to_hash)
      end

      def copy(incoming={})
        Organization.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
      end

      def to_hash
        {
          :guid => guid,
          :name => name
        }
      end

    end

    class User

      attr_reader :guid, :email, :active, :age_group, :tags

      def initialize(incoming={})
        opts = HttpClient::Helper.symbolize_keys(incoming)
        @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
        @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
        @active = HttpClient::Preconditions.assert_boolean('active', opts.delete(:active))
        @age_group = HttpClient::Preconditions.assert_class('age_group', opts[:age_group].nil? ? nil : (opts[:age_group].is_a?(ApidocReferenceApi::Models::AgeGroup) ? opts.delete(:age_group) : ApidocReferenceApi::Models::AgeGroup.apply(opts.delete(:age_group))), ApidocReferenceApi::Models::AgeGroup)
        @tags = (opts.delete(:tags) || {}).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class_or_nil('tags', d[1], String); h }
      end

      def to_json
        JSON.dump(to_hash)
      end

      def copy(incoming={})
        User.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
      end

      def to_hash
        {
          :guid => guid,
          :email => email,
          :active => active,
          :age_group => age_group.nil? ? nil : age_group.value,
          :tags => tags
        }
      end

    end

    class UserList

      attr_reader :users

      def initialize(incoming={})
        opts = HttpClient::Helper.symbolize_keys(incoming)
        @users = HttpClient::Preconditions.assert_class('users', opts.delete(:users), Array).map { |el| el.nil? ? nil : (el.is_a?(ApidocReferenceApi::Models::User) ? el : ApidocReferenceApi::Models::User.new(el)) }
      end

      def to_json
        JSON.dump(to_hash)
      end

      def copy(incoming={})
        UserList.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
      end

      def to_hash
        {
          :users => (users || []).map(&:to_hash)
        }
      end

    end

  end

  # ===== END OF SERVICE DEFINITION =====
  module HttpClient

    class Request

      def initialize(uri)
        @uri = Preconditions.assert_class('uri', uri, URI)
        @params = nil
        @body = nil
        @auth = nil
        @headers = {}
        @header_keys_lower_case = []
      end

      def with_header(name, value)
        Preconditions.check_not_blank('name', name, "Header name is required")
        Preconditions.check_not_blank('value', value, "Header value is required")
        Preconditions.check_state(!@headers.has_key?(name),
                                  "Duplicate header named[%s]" % name)
        @headers[name] = value
        @header_keys_lower_case << name.downcase
        self
      end

      def with_auth(auth)
        Preconditions.assert_class('auth', auth, HttpClient::Authorization)
        Preconditions.check_state(@auth.nil?, "auth previously set")

        if auth.scheme.name == AuthScheme::BASIC.name
          @auth = auth
        else
          raise "Auth Scheme[#{auth.scheme.name}] not supported"
        end
        self
      end

      def with_query(params)
        Preconditions.assert_class('params', params, Hash)
        Preconditions.check_state(@params.nil?, "Already have query parameters")
        @params = params
        self
      end

      # Wrapper to set Content-Type header to application/json and set
      # the provided json document as the body
      def with_json(json)
        @headers['Content-Type'] ||= 'application/json; charset=UTF-8'
        with_body(json)
      end

      def with_body(body)
        Preconditions.check_not_blank('body', body)
        @body = body
        self
      end

      # Creates a new Net:HTTP client. The client returned should be
      # fully configured to make a request.
      def new_http_client
        client = Net::HTTP.new(@uri.host, @uri.port)
        if @uri.scheme == "https"
          configure_ssl(client)
        end
        client
      end

      # If HTTP is required, this method accepts an HTTP Client and configures SSL
      def configure_ssl(client)
        Preconditions.assert_class('client', client, Net::HTTP)
        client.use_ssl = true
        client.verify_mode = OpenSSL::SSL::VERIFY_PEER
        client.cert_store = OpenSSL::X509::Store.new
        client.cert_store.set_default_paths
      end

      def get(&block)
        do_request(Net::HTTP::Get, &block)
      end

      def delete(&block)
        do_request(Net::HTTP::Delete, &block)
      end

      def options(&block)
        do_request(Net::HTTP::Options, &block)
      end

      def post(&block)
        do_request(Net::HTTP::Post, &block)
      end

      def put(&block)
        do_request(Net::HTTP::Put, &block)
      end

      class PATCH < Net::HTTP::Put
        METHOD = "PATCH"
      end

      def patch(&block)
        do_request(PATCH, &block)
      end

      def do_request(klass)
        Preconditions.assert_class('klass', klass, Class)

        uri = @uri.to_s
        if q = to_query(@params)
          uri += "?%s" % q
        end

        request = klass.send(:new, uri)

        curl = ['curl']
        if klass != Net::HTTP::Get
          curl << "-X%s" % klass.name.split("::").last.upcase
        end

        if @body
          # DEBUG path = "/tmp/rest_client.tmp"
          # DEBUG File.open(path, "w") { |os| os << @body.to_s }
          # DEBUG curl << "-d@%s" % path
          request.body = @body
        end

        if @auth
          curl << "-u \"%s:%s\"" % [@auth.username, @auth.password]
          Preconditions.check_state(!@header_keys_lower_case.include?("authorization"),
                                    "Cannot specify both an Authorization header and an explicit username")
          user_pass = "%s:%s" % [@auth.username, @auth.password]
          encoded = Base64.encode64(user_pass).to_s.split("\n").map(&:strip).join
          request.add_field("Authorization", "Basic %s" % encoded)
        end

        @headers.each do |key, value|
          curl <<  "-H \"%s: %s\"" % [key, value]
          request.add_field(key, value)
        end

        curl << "'%s'" % uri
        # DEBUG puts curl.join(" ")

        raw_response = http_request(request)
        response = raw_response.to_s == "" ? nil : JSON.parse(raw_response)

        if block_given?
          yield response
        else
          response
        end
      end

      private
      def to_query(params={})
        parts = (params || {}).map do |k,v|
          if v.respond_to?(:each)
            v.map { |el| "%s=%s" % [k, CGI.escape(el.to_s)] }
          else
            "%s=%s" % [k, CGI.escape(v.to_s)]
          end
        end
        parts.empty? ? nil : parts.join("&")
      end

      def http_request(request)
        response = new_http_client.request(request)

        case response
        when Net::HTTPSuccess
          response.body
        else
          body = response.body rescue nil
          raise HttpClient::ServerError.new(response.code.to_i, response.message, :body => body)
        end
      end
    end

    class ServerError < StandardError

      attr_reader :code, :details, :body

      def initialize(code, details, incoming={})
        opts = HttpClient::Helper.symbolize_keys(incoming)
        @code = HttpClient::Preconditions.assert_class('code', code, Integer)
        @details = HttpClient::Preconditions.assert_class('details', details, String)
        @body = HttpClient::Preconditions.assert_class_or_nil('body', opts.delete(:body), String)
        HttpClient::Preconditions.assert_empty_opts(opts)
        super(self.message)
      end

      def message
        m = "%s %s" % [@code, @details]
        if @body
          m << ": %s" % @body
        end
        m
      end

      def body_json
        JSON.parse(@body)
      end

    end

    module Preconditions

      def Preconditions.check_argument(expression, error_message=nil)
        if !expression
          raise error_message || "check_argument failed"
        end
        nil
      end

      def Preconditions.check_state(expression, error_message=nil)
        if !expression
          raise error_message || "check_state failed"
        end
        nil
      end

      def Preconditions.check_not_nil(field_name, reference, error_message=nil)
        if reference.nil?
          raise error_message || "argument for %s cannot be nil" % field_name
        end
        reference
      end

      def Preconditions.check_not_blank(field_name, reference, error_message=nil)
        if reference.to_s.strip == ""
          raise error_message || "argument for %s cannot be blank" % field_name
        end
        reference
      end

      # Throws an error if opts is not empty. Useful when parsing
      # arguments to a function
      def Preconditions.assert_empty_opts(opts)
        if !opts.empty?
          raise "Invalid opts: #{opts.keys.inspect}\n#{opts.inspect}"
        end
      end

      # Asserts that value is not nill and is_?(klass). Returns
      # value. Common use is
      #
      # amount = Preconditions.assert_class('amount', amount, BigDecimal)
      def Preconditions.assert_class(field_name, value, klass)
        Preconditions.check_not_nil('field_name', field_name)
        Preconditions.check_not_nil('klass', klass)
        Preconditions.check_not_nil('value', value, "Value for %s cannot be nil. Expected an instance of class %s" % [field_name, klass.name])
        Preconditions.check_state(value.is_a?(klass),
                                  "Value for #{field_name} is of type[#{value.class}] - class[#{klass}] is required. value[#{value.inspect.to_s}]")
        value
      end

      def Preconditions.assert_class_or_nil(field_name, value, klass)
        if !value.nil?
          Preconditions.assert_class(field_name, value, klass)
        end
      end

      def Preconditions.assert_boolean(field_name, value)
        Preconditions.check_not_nil('field_name', field_name)
        Preconditions.check_not_nil('value', value, "Value for %s cannot be nil. Expected an instance of TrueClass or FalseClass" % field_name)
        Preconditions.check_state(value.is_a?(TrueClass) || value.is_a?(FalseClass),
                                  "Value for #{field_name} is of type[#{value.class}] - class[TrueClass or FalseClass] is required. value[#{value.inspect.to_s}]")
        value
      end

      def Preconditions.assert_boolean_or_nil(field_name, value)
        if !value.nil?
          Preconditions.assert_boolean(field_name, value)
        end
      end

      def Preconditions.assert_collection_of_class(field_name, values, klass)
        Preconditions.assert_class(field_name, values, Array)
        values.each { |v| Preconditions.assert_class(field_name, v, klass) }
      end

      def Preconditions.assert_hash_of_class(field_name, hash, klass)
        Preconditions.assert_class(field_name, hash, Hash)
        values.each { |k, v| Preconditions.assert_class(field_name, v, klass) }
      end

    end

    class AuthScheme

      attr_reader :name

      def initialize(name)
        @name = HttpClient::Preconditions.check_not_blank('name', name)
      end

      BASIC = AuthScheme.new("basic") unless defined?(BASIC)

    end

    class Authorization

      attr_reader :scheme, :username, :password

      def initialize(scheme, username, opts={})
        @scheme = HttpClient::Preconditions.assert_class('schema', scheme, AuthScheme)
        @username = HttpClient::Preconditions.check_not_blank('username', username, "username is required")
        @password = HttpClient::Preconditions.assert_class_or_nil('password', opts.delete(:password), String)
        HttpClient::Preconditions.assert_empty_opts(opts)
      end

      def Authorization.basic(username, password=nil)
        Authorization.new(AuthScheme::BASIC, username, :password => password)
      end

    end

    module Helper

      def Helper.symbolize_keys(hash)
        Preconditions.assert_class('hash', hash, Hash)
        new_hash = {}
        hash.each do |k, v|
          new_hash[k.to_sym] = v
        end
        new_hash
      end

      def Helper.to_big_decimal(value)
        value ? BigDecimal.new(value.to_s) : nil
      end

      def Helper.to_object(value)
        value ? JSON.parse(value) : nil
      end

      def Helper.to_uuid(value)
        Preconditions.check_state(value.nil? || value.match(/^\w\w\w\w\w\w\w\w\-\w\w\w\w\-\w\w\w\w\-\w\w\w\w\-\w\w\w\w\w\w\w\w\w\w\w\w$/),
                                  "Invalid guid[%s]" % value)
        value
      end

      def Helper.to_date_iso8601(value)
        if value.is_a?(Date)
          value
        elsif value
          Date.parse(value.to_s)
        else
          nil
        end
      end

      def Helper.to_date_time_iso8601(value)
        if value.is_a?(DateTime)
          value
        elsif value
          DateTime.parse(value.to_s)
        else
          nil
        end
      end

      def Helper.date_iso8601_to_string(value)
        value.nil? ? nil : value.strftime('%Y-%m-%d')
      end

      def Helper.date_time_iso8601_to_string(value)
        value.nil? ? nil : value.strftime('%Y-%m-%dT%H:%M:%S%z')
      end

      TRUE_STRINGS = ['t', 'true', 'y', 'yes', 'on', '1', 'trueclass'] unless defined?(TRUE_STRINGS)
      FALSE_STRINGS = ['f', 'false', 'n', 'no', 'off', '0', 'falseclass'] unless defined?(FALSE_STRINGS)

      def Helper.to_boolean(field_name, value, opts={})
        string = value.to_s.strip.downcase
        if TRUE_STRINGS.include?(string)
          true
        elsif FALSE_STRINGS.include?(string)
          false
        elsif string != ""
          raise "Unsupported boolean value[#{string}]. For true, must be one of: #{TRUE_STRINGS.inspect}. For false, must be one of: #{FALSE_STRINGS.inspect}"
        else
          nil
        end
      end

    end

  end
end
